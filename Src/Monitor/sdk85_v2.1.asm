;**********************************************************************
;
;                       PROGRAM: SDK-85 MONITOR     VER 2.1 
;
;                       COPYRIGHT (C) 1977 
;                       INTEL CORPORATION 
;                       3865 BOWERS AVENUE 
;                       SANTA CLARA, CALIFORNIA     95051
;
;**********************************************************************
; ABSTRACT 
; ======== 
;
; THIS PROGRAM IS A SMALL MONITOR FOR THE INTEL 8885 KIT AND
; PROVIDES A MINIMUM LEVEL OF UTILITY FUNCTIONS FOR THE USER EMPLOYING
; EITHER AN INTER-ACTIVE CONSOLE (I.E. TELETYPE) OR THE KIT'S 
; KEYBOARD/LED DISPLAY. THE KEYBOARD MONITOR ALLOWS THE USER TO PERFORM
; SUCH FUNCTIONS AS MEMORY AND REGISTER MANIPULATION, PROGRAM LOADING,
; PROGRAM EXECUTION, INTERRUPTION OF AN EXECUTING PROGRAM, AND
; SYSTEM RESET.
; 
; PROGRAM ORGANIZATION 
; ======= ============
;
; THE PROGRAM IS ORGANIZED AS FOLLOWS :-
;       1) COLD START ROUTINE (RESET)
;       2) WARM START -REGISTER SAVE ROUTINE 
;       3) INTERRUPT VECTORS 
;       4) KEYBOARD MONITOR 
;       5) TTY MONITOR 
;       6) LAYOUT OF RAM USAG
; 
; THE KEYBOARD MONITOR BEGINS WITH THE COMMAND RECOGNIZER, FOLLOWED BY
; THE COMMAND ROUTINE SECTION, UTILITY ROUTINE SECTION AND MONITOR
; TABLES. THE COMMAND AND UTILITY ROUTINES ARE IN ALPHABETICAL ORDER
; WITHIN THEIR RESPECTIVE SECTIONS.
; THROUGHOUT THE KEYBOARD MONITOR, A COMMENT FIELD BEGINNING
; WITH "ARG - " INDICATES A STATEMENT WHICH LOADS A VALUE INTO
; A REGISTER AS AN ARGUMENT FOR A FUNCTION. WHEN THE DESIRED VALUE
;
; LIST OF KEYBOARD MONITOR ROUTINES 
; ==== == ======== ======= ========
;
; CMMND 
; -----
; EXAM 
; GOCMD 
; SSTEP 
; SUBST 
; -----
; CLEAR
; CLDIS
; CLOST
; DISPC 
; ERR
; GTHEX 
; HXDSP 
; ININT 
; INSDG 
; NXTRG 
; OUTPT 
; RDKBD 
; RETF 
; RETT 
; RGLOC 
; RSTOR 
; SETRG 
; UPDAD 
; UPDDT 
        NAME    SDK85 
; 
;**********************************************************************
;
;                       SET CONDITIONAL ASSEMBLY FLAG 
; 
;**********************************************************************
;
;
;WAITS  SET      0      ;0=NO WAIT STATES 
                        ;1-A WAIT STATE IS GENERATED FOR EVERY M CYCLE
                        ;THE APPROPRIATE DELAY TIME MUST BE USED FOR
                        ;TTY DELAY OR SET UP SINGLE 
                        ;STEP TIMER FOR EACH CASE
;  
; 
;**********************************************************************
;
;                       MONITOR EQUATES 
; 
;**********************************************************************
;
;
RAMST   EQU     2000H   ; START ADDRESS OF RAM -THIS PROGRAM ASSUMES
; THAT 256 BYTES OF RANDOM ACCESS MEMORY BEGIN AT THIS ADDRESS.
; THE PROGRAM USES STORAGE AT THE END OF THIS SPACE FOR VARIABLES,
; SAVING REGISTERS AND THE PROGRAM STACK 
;

RMUSE   EQU     23      ; RAM USAGE - CURRENTLY, 23 BYTES ARE USED FOR 
                        ; /SAVING REGISTERS AND VARIABLES 
; 
SKLN    EQU     24      ; MONITOR STACK USAGE - MAX OF 12 LEVELS 
; 
UBRLN   EQU     15      ; 5 USER BRANCHES - 3 BYTES EACH 
; 
ADFLD   EQU     0       ; INDICATES USE OF ADDRESS FIELD OF DISPLAY 
ADISP   EQU     90H     ; CONTROL CHARACTER TO INDICATE OUTPUT TO 
                        ; /ADDRESS FIELD OF DISPLAY 
CNTRL   EQU     1900H   ; ADDRESS FOR SENDING CONTROL CHARACTERS TO 
                        ; /DISPLAY CHIP 
COMMA   EQU     11H     ; COMMA FROM KEYBOARD 
CSNIT   EQU     0       ; INITIAL VALUE FOR COMMAND STATUS REGISTER 
CSR     EQU     20H     ; OUTPUT PORT FOR COMMAND STATUS REGISTER 
DDISP   EQU     94H     ; CONTROL CHARACTER TO INDICATE OUTPUT TO 
                        ; /DATA FIELD OF DISPLAY 
DOT     EQU     1       ; INDICATOR FOR DOT IN DISPLAY 
DSPLY   EQU     1800H   ; ADDRESS FOR SENDING CHARACTERS TO DISPLAY 
DTFLD   EQU     1       ; INDICATES USE OF DATA FIELD OF DISPLAY 
DTMSK   EQU     08H     ; MASK FOR TURNING ON DOT IN DISPLAY 
EMPTY   EQU     80H     ; HIGH ORDER 1 INDICATES EMPTY INPUT BUFFER 
KBNIT   EQU     0CCH    ; CONTROL CHARACTER TO SET DISPLAY OUTPUT TO 
                        ; /ALL ONES DURING BLANKING PERIOD 
KMODE   EQU     0       ; CONTROL CHAR. TO SET KEYBOARD/DISPLAY MODE 
                        ; (2 KEY ROLLOVER, 8 CHARACTER LEFT ENTRY) 
MNSTK   EQU     RAMST + 256 - RMUSE     ; START OF MONITOR STACK 
NODOT   EQU     0       ; INDICATOR FOR NO DOT IN DISPLAY 
;NUMC - DEFINED LATER   ; NUM8ER OF COMMANDS 
;NUMRG - DEFINED LATER  ; NUMBER OF REGISTER SAVE LOCATIONS 
PERIO   EQU     10H     ; PERIOD FROM KEYBOARD 
PRMPT   EQU     0FBH    ; PROMPT CHARACTER FOR DISPLAY (DASH) 
READ    EQU     40H     ; CONTROL CHARACTER TO INDICATE INPUT FROM 
                        ; /KEYBOARD 
TIMHI   EQU     25H     ; OUTPUT PORT FOR HIGH ORDER BYTE OF TIMER VALUE 
TIMLO   EQU     24H     ; OUTPUT PORT FOR LOW ORDER BYTE OF TIMER VALUE 
TMODE   EQU     40H     ; TIMER MODE - SOUARE WAVE, AUTO RELOAD 
TSTRT   EQU     0C0H    ; START TIMER 
UNMSK   EQU     0EH     ; UNMASK INPUT INTERRUPT 
USRBR   EQU     RAMST + 256 -(RMUSE + SKLN + UBRLN)     ; START OF USER 
                        ; /BRANCH LOCATIONS 
;        IF      1-WAITS ; TIMER VALUE FOR SINGLE STEP IF NO WAIT STATE 
TIMER   EQU     197 
;        ENDIF 
;        IF      WAITS   ; TIMER VALUE FOR SINGLE STEP IF ONE WAIT STATE INSERTED 
;TIMER   EQU     237 
;        ENDIF 
;
;********************************************************************
;
;
;                   MONITOR MACROS
;
;
;********************************************************************
;
;TRUE    MACRO   WHERE   ; BRANCH IF FUNCTION RETURNS TRUE (SUCCESS)
;        JC      WHERE
;        ENDM
;
;FALSE   MACRO   WHERE   ; BRANCH IF FUNCTION RETURNS FALSE (FAILURE)
;        JNC     WHERE
;        ENDM
;
;********************************************************************
;
; ***** "RESET" KEY ENTRY POINT - COLD START 
; ***** RST 0 ENTRY POINT 
;
        ORG     0
        MVI     A,KMODE ; GET CONTROL CHARACTER 
        STA     CNTRL   ; SET KEYBOARD/DISPLAY MODE 
        JMP     CLDST   ; GO FINISH COLO START 
CLDBK:                  ; THEN JUMP BACK HERE 
; 
; ***** RST 1 ENTRY POINT -WARM START 
; 
        ORG     8 
;       SAVE REGISTERS 
        SHLD    LSAV    ; SAVE H & L REGISTERS 
        POP     H       ; GET USER PROGRAM COUNTER FROM TOP OF STACK 
        SHLD    PSAV    ; /AND SAVE IT 
        PUSH    PSW 
        POP     H 
        SHLD    FSAV    ; SAVE FLIP/FLOPS & REGISTER A 
        LXI     H,0     ; CLEAR H & L 
        DAD     SP      ; GET USER STACK POINTER 
        SHLD    SSAV    ; /AND SAVE IT 
        LXI     H,BSAV+1 ; SET STACK POINTER FOR SAVING 
        SPHL            ; /REMAINING REGISTERS 
        PUSH    B       ; SAVE B & C 
        PUSH    D       ; SAVE D & E 
        JMP     RES10   ; LEAVE ROOM FOR VECTORED INTERRUPTS 
;
; ***** TIMER INTERRUPT (TRAP) ENTRY POINT (RST 4.5) 
        ORG     24H 
        JMP     STP25   ; BACK TO SINGLE STEP ROUTINE 
; 
; ***** RST 5 ENTRY POINT 
;
        ORG     28H
        JMP     RSET5   ; BRANCH TO RST 5 LOCATION IN RAM 
;
; ***** INPUT INTERRUPT ENTRY POINT (RST 5.5)
;
        ORG     2CH 
        JMP     ININT   ; BRANCH TO INPUT INTERRUPT ROUTINE
; 
; ***** RST 6 ENTRY POINT 
;
        ORG     30H 
        JMP     RSET6   ; BRANCH TO RST 6 LOCATION IN RAM 
; 
; ***** HARD WIRED USER INTERRUPT ENTRY POINT (RST 6.5) 
;
        ORG     34H 
        JMP     RST65   ; BRANCH TO RST 6.5 LOCATION IN RAM 
; 
; ***** RST 7 ENTRY POINT 
;
        ORG     38H 
        JMP     RSET7   ; BRANCH TO RST 7 LOCATION IN RAM 
;
; ***** "VECTORED INTERRUPT" KEY ENTRY POINT (RST 7.5)
        ORG     3CH 
        JMP     USINT   ; BRANCH TO USER INTERRUPT LOCATION IN RAM 
;
RES10:                  ; CONTINUE SAVING USER STATUS
        RIM             ; GET USER INTERRUPT STATUS AND INTERRUPT MASK
        ANI     0FH     ; KEEP STATUS, MASK BITS 
        STA     ISAV    ; SAVE INTERRUPT STATUS & MASK 
        MVI     A,UNMSK ; UNMASK INTERRUPTS FOR MONITOR USE 
        SIM 
        DI              ; INTERRUPTS DISABLED WHILE MONITOR IS RUNNING 
                        ; (EXCEPT WHEN WAITING FOR INPUT) 
        RIM             ; TTY OR KEYBOARD MONITOR ?
        RLC             ; IS TTY CONNECTED ?
        JC      GO      ; YES -BRANCH TO TTY MONITOR
                        ; NO -ENTER KEYBOARD MONITOR
;
;********************************************************************
;
;                       BEGINNING OF KEYBOARD MONITOR CODE
;
;********************************************************************
;
;       OUTPUT SIGN-ON MESSAGE
        XRA     A       ; ARG - USE ADDRESS FIELD OF DISPLAY
        MVI     B,NODOT ; ARG - NO DOT IN ADDRESS FIELD
        LXI     H,SGNAD ; ARG - USE ADDRESS FIELD OF DISPLAY 
                        ; /SIGN-ON MESSAGE 
        CALL    OUTPT   ; OUTPUT SIGN-ON MESSAGE TO ADDRESS FIELD 
        MVI     A,DTFLD ; ARG - USE DATA FIELD OF DISPLAY 
        MVI     B,NODOT ; ARG - NO DOT IN DATA FIELD 
        LXI     H,SGNDT ; ARG - GET ADDRESS OF DATA FIELD PORTION OF 
                        ; /SIGN-ON MESSAGE 
        CALL    OUTPT   ; OUTPUT SIGN-ON MESSAGE TO DATA FIELD 
        MVI     A,EMPTY
        STA     IBUFF   ; SET INPUT BUFFER EMPTY FLAG 
;
;********************************************************************
;
; FUNCTION: CMMND - COMMAND RECOGNIZER
; INPUTS: NONE
; OUTPUTS: NONE 
; CALLS: RDKBD,ERR,SUBST,EXAM,GOCMD,SSTEP 
; DESTROYS: A,B,C,D,E,H,L,F/F'S
;
CMMND: 
        LXI     H,MNSTK ; INITIALIZE MONITOR STACK POINTER 
        SPHL
                        ; OUTPUT PROMPT CHARACTER TO DISPLAY 
        LXI     H,CNTRL ; GET ADDRESS FOR CONTROL CHARACTER 
        MVI     M,ADISP ; OUTPUT CONTROL CHARACTER TO USE ADDRESS FIELD 
        DCR     H       ; ADDRESS FOR OUTPUT CHARACTER
        MVI     M,PRMPT ; OUTPUT PROMPT CHARACTER 
        CALL    RDKBD   ; READ KEYBOARD  
        LXI     B,NUMC  ; COUNTER FOR NUMBER OF COMMANDS IN C
        LXI     H,CMDTB ; GET ADDRESS OF COMMAND TABLE 
CMD10:
        CMP     M       ; RECOGNIZE THE COMMAND ?
        JZ      CMD15   ; YES - GO PROCESS IT
        INX     H       ; NO - NEXT COMMAND TABLE ENTRY
        DCR     C       ; END OF TABLE ?
        JNZ     CMD10   ; NO - GO CHECK NEXT ENTRY
                        ; YES -COMMAND UNKNOWN 
        JMP     ERR     ; DISPLAY ERROR MESSAGE AND GET ANOTHER COMMAND 
CMD15:
        LXI     H,CMDAD ; GET ADDRESS OF COMMAND ADDRESS TABLE
        DCR     C       ; ADJUST COMMAND COUNTER 
                ;COUNTER ACTS AS POINTER TO COMMAND ADDRESS TABLE
        DAD     B       ; ADD POINTER TO TABLE ADDRESS TWICE BECAUSE
        DAD     B       ; TABLE HAS 2 BYTE ENTRIES
        MOV     A,M     ; GET LOW ORDER BYTE OF COMMAND ADDRESS
        INX     H
        MOV     H,M     ; GET HIGH ORDER BYTE OF COMMAND ADDRESS IN H
        MOV     L,A     ; PUT LOW ORDER BYTE IN L
                ;COMMAND ROUTINE ADDRESS IS NOW IN H & L
        PCHL            ; BRANCH TO ADDRESS IN H & L 
;
;********************************************************************
;
;                       COMMAND ROUTINES 
;
;********************************************************************
;
; FUNCTION: EXAM - EXAMINE AND MODIFY REGISTERS 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: CLEAR,SETRG,ERR,RGNAM,RGLOC,UPDDT,GTHEX,NXTRG 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; 
EXAM: 

        MVI     B,DOT   ; ARG - DOT IN ADDRESS FIELD OF DISPLAY
        CALL    CLEAR   ; CLEAR DISPLAY
        CALL    SETRG   ; GET REGISTER DESIGNATOR FROM KEYBOARD AND
                        ; /SET REGISTER POINTER ACCORDINGLY
                        ; WAS CHARACTER A REGISTER DESIGNATOR?
;        FALSE   ERR     ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
        JNC     ERR
EXM05: 
        CALL    RGNAM   ; OUTPUT REGISTER NAME TO ADDRESS FIELD
        CALL    RGLOC   ; GET REGISTER SAVE LOCATION IN H & L
        MOV     A,M     ; GET REGISTER CONTENTS
        STA     CURDT   ; STORE REGISTER CONTENTS AT CURRENT DATA
        MVI     B,DOT   ;  ARG - DOT IN DATA FIELD
        CALL    UPDDT   ; UPDATE DATA FIELD OF DISPLAY
        MVI     B,DTFLD ; ARG - USE DATA FIELD OF DISPLAY
        CALL    GTHEX   ; GET HEX DIGITS - WERE ANY DIGITS RECEIVED?
;        FALSE   EXM10   ; NO - DO NOT UPDATE REGISTER CONTENTS
        JNC     EXM10
        CALL    RGLOC   ; YES - GET REGISTER SAVE LOCATION IN H & L
        MOV     M,E     ; UPDATE REGISTER CONTENTS
EXM10:
        CPI     PERIO   ; WAS LAST CHARACTER A PERIOD ?
        JZ      CLDIS   ; YES - CLEAR DISPLAY AND TERMINATE COMMAND
        CPI     COMMA   ; WAS LAST CHARACTER ',' ?
        JNZ     ERR     ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
        CALL    NXTRG   ; YES - ADVANCE REGISTER POINTER TO
                        ; /NEXT REGISTER
                        ; ANY MORE REGISTERS ?
;        TRUE    EXM05   ; YES - CONTINUE PROCESSING WITH NEXT REGISTER
        JC      EXM05
        JMP     CLDIS   ; NO - CLEAR DISPLAY AND TERMINATE COMMAND
;
;********************************************************************
;
; FUNCTION: GOCMD - EXECUTE USER PROGRAM 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: DISPC,RDKBD,CLEAR,GTHEX,ERR,OUTPT 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; 
GOCMD:
        CALL    DISPC   ; DISPLAY USER PROGRAM COUNTER
        CALL    RDKBD   ; READ FROM KEYBOARD
        CPI     PERIO   ; IS CHARACTER A PERIOD ?
        JZ      G10     ; YES - GO EXECUTE THE COMMAND
                        ; NO - ARG - CHARACTER IS STILL IN A
        STA     IBUFF   ; REPLACE CHARACTER IN INPUT BUFFER
        MVI     B,DOT   ; ARG - DOT IN ADDRESS FIELD
        CALL    CLEAR   ; CLEAR DISPLAY
        MVI     B,ADFLD ; ARG - USE ADDRESS FIELD
        CALL    GTHEX   ; GET HEX DIGITS
        CPI     PERIO   ; WAS LAST CHARACTER A PERIOD
        JNZ     ERR     ; NO -  DISPLAY ERROR MSG. AND TERMINATE COMMAND
        XCHG            ; PUT HEX VALUE FROM GTHEX TO H & L
        SHLD    PSAV    ; HEX VALUE IS NEW USER PC
G10:
        MVI     B,NODOT ; YES - ARG - NO DOT IN ADDRESS FIELD
        CALL    CLEAR   ; CLEAR DISPLAY
        XRA     A       ; ARG - USE ADDRESS FIELD OF DISPLAY
        MVI     B,NODOT ; ARG - NO DOT IN ADDRESS FIELD
        LXI     H,EXMSG ; GET ADDRESS OF EXECUTION MESSAGE IN H & L
        CALL    OUTPT   ; DISPLAY EXECUTION MESSAGE
        JMP     RSTOR   ; RESTORE USER REGISTERS INCL. PROGRAM COUNTER
                        ; /I.E. BEGIN EXECUTION OF USER PROGRAM
;
;********************************************************************
;
; FUNCTION: SSTEP - SINGLE STEP (EXECUTE ONE USER INSTRUCTION)
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: DISPC,RDKBD,CLEAR,GTHEX,ERR
; DESTROYS: A,B,C,D,E,H,L,F/F'S
;
SSTEP:
        CALL    DISPC   ; DISPLAY USER PROGRAM COUNTER
        CALL    RDKBD   ; READ FROM KEYBOARD
        CPI     PERIO   ; WAS CHARACTER A PERIOD ?
        JZ      CLDIS   ; YES - CLEAR DISPLAY AND TERMINATE COMMAND
        CPI     COMMA   ; WAS LAST CHARACTER ','?
        JZ      STP20   ; YES - GO SET TIMER
                        ; NO - CHARACTER FROM KEYBOARD WAS NEITHER PERIOD NOR COMMA
        STA     IBUFF   ; REPLACE THE CHARACTER IN THE INPUT BUFFER
        MVI     B,DOT   ; ARG - DOT IN ADDRESS FIELD
        CALL    CLEAR   ; CLEAR DISPLAY
        MVI     B,ADFLD ; ARG - USE ADDRESS FIELD OF DISPLAY
        CALL    GTHEX   ; GET HEX DIGITS - WERE ANY DIGITS RECEIVED ?
;        FALSE   ERR     ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
        JNC     ERR
        XCHG            ; HEX VALUE FROM GTHEX TO H & L
        SHLD    PSAV    ; HEX VALUE IS NEW USER PC
        CPI     PERIO   ; WAS LAST CHARACTER FROM GTHEX A PERIOD ?
        JZ      CLDIS   ; YES - CLEAR DISPLAY AND TERMINATE COMMAND
                        ; NO - MUST HAVE BEEN A COMMA
STP20:
        LDA     ISAV    ; GET USER INTERRUPT MASK
        ANI     08H     ; KEEP INTERRUPT STATUS
        STA     TEMP    ; SAVE USER INTERRUPT STATUS
        LHLD    PSAV    ; GET USER PC
        MOV     A,M     ; GET USER INSTRUCTION
        CPI     0F3H    ; DI INSTRUCTION ?
        JNZ     STP21   ; NO
        XRA     A       ; YES - RESET USER INTERRUPT STATUS
        JMP     STP22
STP21:
        CPI     0FBH    ; EI INSTRUCTION ?
        JNZ     STP23   ; NO
        MVI     A,08H   ; YES - SET USER INTERRUPT STATUS
STP22:
        STA     TEMP    ; SAVE NEW USER INTERRUPT STATUS
STP23:
        MVI     A, HIGH(TIMER) OR TMODE ; HIGH ORDER BITS OF TIMER VALUE
                        ; /OR'ED WITH TIMER MODE
        OUT     TIMHI
        MVI     A, LOW(TIMER) ; LOW ORDER BITS OF TIMER VALUE
        OUT     TIMLO
        LDA     USCSR   ; GET USER IMAGE OF WHAT'S IN CSR
        ORI     TSTRT   ; SET TIMER COMMAND BITS TO START TIMER
        OUT     CSR     ; START TIMER
        JMP     RSTOR   ; RESTORE USER REGISTERS
;
STP25:                  ; BRANCH HERE WHEN TIMER INTERRUPTS AFTER
                        ; /ONE USER INSTRUCTION
        PUSH    PSW     ; SAVE PSW
        LDA     USCSR   ; GET USER IMAGE OF WHAT'S IN CSR
        ANI     3FH     ; CLEAR 2 HIGH ORDER BITS
        ORI     40H     ; SET TIMER STOP BIT
        OUT     CSR     ; STOP TIMER
        POP     PSW     ; RETRIEVE PSW
        SHLD    LSAV    ; SAVE H , L
        POP     H       ; GET USER PROGRAM COUNTER FROM TOP OF STACK
        SHLD    PSAV    ; SAVE USER PC
        PUSH    PSW
        POP     H
        SHLD    FSAV    ; SAVE FLIP/FLOPS AND A REGISTER
        LXI     H,0     ; CLEAR H & L
        DAD     SP      ; GET USER STACK POINTER
        SHLD    SSAV    ; SAVE USER STACK POINTER
        LXI     H,BSAV+1    ; SET MONITOR STACK POINTER FOR
        SPHL            ; /SAVING REMAINING USER REGISTERS
        PUSH    B       ; SAVE B & C
        PUSH    D       ; SAVE D & E 
        RIM             ; GET USER INTERRUPT MASK 
        ANI     07H     ; KEEP MASK BITS 
        LXI     H,TEMP  ; GET USER INTERRUPT STATUS 
        ORA     M       ; OR IT INTO MASK 
        STA     ISAV    ; SAVE INTERRUPT STATUS & MASK 
        MVI     A,UNMSK ; UNMASK INTERRUPTS FOR MONITOR USE 
        SIM 
        JMP     SSTEP   ; GO GET READY FOR ANOTHER INSTRUCTION 
;
;********************************************************************
;
; FUNCTION: SUBST - SUBSTITUTE MEMORY 
; INPUTS: NONE 
; OUTPUTS: NONE
; CALLS: CLEAR,GTHEX,UPDAD,UPDDT,ERR
; DESTROYS: A,B,C,D,E,H,L,F/F'S
;
SUBST:
        MVI     B,DOT   ; ARG - DOT IN ADDRESS FIELD
        CALL    CLEAR   ; CLEAR THE DISPLAY
        MVI     B,ADFLD ; ARG - USE ADDRESS FIELD OF DISPLAY
        CALL    GTHEX   ; GET HEX DIGITS - WERE ANY DIGITS RECEIVED?
;        FALSE   ERR     ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
        JNC     ERR
        XCHG            ; ASSIGN HEX VALUE RETURNED BY GTHEX TO
        SHLD    CURAD   ; / CURRENT ADDRESS
SUB05:
        CPI     COMMA   ; WAS ',' THE LAST CHARACTER FROM KEYBOARD?
        JNZ     SUB15   ; NO - GO TERMINATE THE COMMAND
        MVI     B,NODOT ; ARG - NO DOT IN ADDRESS FIELD
        CALL    UPDAD   ; UPDATE ADDRESS FIELD OF DISPLAY
        LHLD    CURAD   ; GET CURRENT ADDRESS IN H & L
        MOV     A,M     ; GET DATA BYTE POINTED TO BY CURRENT ADDRESS
        STA     CURDT   ; STORE DATA BYTE AT CURRENT DATA
        MVI     B,DOT   ; ARG - DOT IN DATA FIELD
        CALL    UPDDT   ; UPDATE DATA FIELD OF DISPLAY
        MVI     B,DTFLD ; ARG - USE DATA FIELD
        CALL    GTHEX   ; GET HEX DIGITS -WERE ANY HEX DIGITS RECEIVED?
        PUSH    PSW     ; (SAVE LAST CHARACTER)
;        FALSE   SUB10   ; NO - LEAVE DATA UNCHANGED AT CURRENT ADDRESS
        JNC     SUB10
        LHLD    CURAD   ; YES - GET CURRENT ADDRESS IN H & L
        MOV     M,E     ; STORE NEW DATA AT CURRENT ADDRESS
                        ; MAKE SURE DATA WAS ACTUALLY STORED IN CASE
                        ;/CURRENT ADDRESS IS IN ROM OR IS NON-EXISTANT
        MOV     A,E     ; DATA TO A FOR COMPARISON 
        CMP     M       ; WAS DATA STORED CORRECTLY?  
        JNZ     ERR     ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND  
SUB10:  
        LHLD    CURAD   ; INCREMENT CURRENT ADDRESS  
        INX     H  
        SHLD    CURAD  
        POP     PSW     ; RETRIEVE LAST CHARACTER  
        JMP  SUB05  
SUB15:  
        CPI     PERIO   ; WAS LAST CHARACTER '.' ?  
        JNZ     ERR     ; NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND  
        JMP     CLDIS   ; YES - CLEAR DISPLAY AND TERMINATE COMMAND  
;
;********************************************************************
;
;                       UTILITY  ROUTINES  
;
;********************************************************************
;
; FUNCTION: CLEAR - CLEAR THE DISPLAY  
; INPUTS: B - DOT FLAG - 1 MEANS PUT DOT IN ADDRESS FIELD OF DISPLAY 
;                      - 0 MEANS NO DOT 
; OUTPUTS: NONE 
; CALLS: OUTPT 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: CLEAR SENDS BLANK CHARACTERS TO BOTH THE ADDRESS FIELD 
;              AND THE DATA FIELD OF THE DISPLAY. IF THE DOT FLAG IS 
;              SET THEN A DOT WILL APPEAR AT THE RIGHT EDGE OF THE 
;              ADDRESS FIELD. 
; 
CLEAR: 
        XRA     A       ; ARG - USE ADDRESS FIELD OF DISPLAY 
                        ; ARG - FLAG FOR DOT IN ADDR. FIELD IS IN B 
        LXI     H,BLNKS ; ARG - ADDRESS OF BLANKS FOR DISPLAY 
        CALL    OUTPT   ; OUTPUT BLANKS TO ADDRESS FIELD 
        MVI     A,DTFLD ; ARG - USE DATA FIELD OF DISPLAY 
        MVI     B,NODOT ; ARG - NO DOT IN DATA FIELD 
        LXI     H,BLNKS ; ARG - ADDRESS OF BLANKS FOR DISPLAY 
        CALL    OUTPT   ; OUTPUT BLANKS TO DATA FIELD 
        RET             ; RETURN 
;
;********************************************************************
;
; FUNCTION: CLDIS - CLEAR DISPLAY AND TERMINATE COMMAND 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: CLEAR 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: CLDIS IS JUMPED TO BY COMMAND ROUTINES WISHING TO 
;              TERMINATE NORMALLY. CLDIS CLEARS THE DISPLAY AND 
;              BRANCHES TO THE COMMAND RECOGNIZER. 
; 
CLDIS: 
        MVI     B,NODOT ; ARG - NO DOT IN ADDRESS FIELD 
        CALL    CLEAR   ; CLEAR THE DISPLAY 
        JMP     CMMND   ; GO GET ANOTHER COMMAND 
;
;********************************************************************
;
; FUNCTION: CLDST - COLD START 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: NOTHING 
; DESTROYS: A 
; DESCRIPTION: CLOST IS JUMPED TO BY THE MAIN COLD START PROCEDURE, 
;              COMPLETES COLD START INITIALIZATION, A~ JUMPS BACK 
;              TO THE MAIN COLD START PROCEDURE. 
; 
CLDST: 
        MVI     A,KBNIT ; GET CONTROL CHARACTER 
        STA     CNTRL   ; INITIALIZE KEYBOARD/DISPLAY BLANKING
        MVI     A,CSNIT ; INITIAL VALUE OF COMMAND STATUS REGISTER 
        OUT     CSR     ; INITIALIZE CSR 
        STA     USCSR   ; INITIALIZE USER CSR VALUE 
        JMP     CLDBK   ; BACK TO MAIN PROCEDURE 
;
;********************************************************************
;
; FUNCTION: DISPC - DISPLAY PROGRAM COUNTER 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: UPDAD,UPDDT 
; DESTROYS: A,B,C,D,E,H,L,F/F'S
; DESCRIPTION: DISPC DISPLAYS THE USER PROGRAM COUNTER IN THE ADDRESS 
;              FIELD OF THE DISPLAY, \'11TH A DOT AT THE RIGHT EDGE 
;              OF THE FIELD. THE BYTE OF DATA ADDRESSED BY THE PROGRAM 
;              COUNTER IS DISPLAYED IN THE DATA FIELD OF THE DISPLAY. 
;
DISPC: 
        LHLD    PSAV    ; GET USER PROGRAM COUNTER 
        SHLD    CURAD   ; MAKE IT THE CURRENT ADDRESS 
        MOV     A,M     ; GET THE INSTRUCTION AT THAT ADDRESS 
        STA     CURDT   ; MAKE IT THE CURRENT DATA 
        MVI     B,DOT   ; ARG - DOT IN ADDRESS FIELD 
        CALL    UPDAD   ; UPDATE ADDRESS FIELD OF DISPLAY 
        MVI     B,NODOT ; ARG - NO DOT IN DATA FIELD 
        CALL    UPDDT   ; UPDATE DATA FIELD OF DISPLAY 
        RET 
; 
;********************************************************************
;
; FUNCTION: ERR - DISPLAY ERROR MESSAGE 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: OUTPT 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: ERR IS JUMPED TO BY COMMAND ROUTINES WISHING TO 
;              TERMINATE BECAUSE OF AN ERROR. 
;              ERR OUTPUTS AN ERROR MESSAGE TO THE DISPLAY AND 
;              BRANCHES TO THE COMMAND RECOGNIZER. 
;
ERR:
        XRA     A       ; ARG - USE ADDRESS FIELD
        MVI     B,NODOT ; ARG - NO DOT IN ADDRESS FIELD
        LXI     H,ERMSG ; ARG - ADDRESS OF ERROR MESSAGE 
        CALL    OUTPT   ; OUTPUT ERROR MESSAGE TO ADDRESS FIELD
        MVI     A,DTFLD ; ARG - USE DATA FIELD
        MVI     B,NODOT ; ARG - NO DOT IN DATA FIELD 
        LXI     H,BLNKS ; ARG - ADDRESS OF BLANKS FOR DISPLAY 
        CALL    OUTPT   ; OUTPUT BLANKS TO DATA FIELD
        JMP     CMMND   ; GO GET A NEW COMMAND 
;
;********************************************************************
;
; FUNCTION: GTHEX - GET HEX DIGITS 
; INPUTS: B - DISPLAY FLAG - 0 MEANS USE ADDRESS FIELD OF DISPLAY 
;                          -1 MEANS USE DATA FIELD OF DISPLAY 
; OUTPUTS: A - LAST CHARACTER READ FROM KEYBOARD 
;          DE - HEX DIGITS FROM KEYBOARD EVALUATED MODULO 2**16 
;          CARRY - SET IF AT LEAST ONE VALID HEX DIGIT WAS READ 
;                - RESET OTHERWISE
; CALLS: RDKBD,INSDG,HXDSP,OUTPT
; DESTROYS, A,B,C,D,E,H,L,F/F'S
; DESCRIPTION: GTHEX ACCEPTS A STRING OF HEX DIGITS FROM THE KEYBOARD, 
;              DISPLAYS THEM AS THEY ARE RECEIVED, AND RETURNS THEIR 
;              VALUE AS A 16 BIT INTEGER. IF MORE THAN 4 HEX DIGITS 
;              ARE RECEIVED, ONLY THE LAST 4 ARE USED. IF THE DISPLAY 
;              FLAG IS SET, THE LAST 2 HEX DIGITS ARE DISPLAYED IN THE
;              DATA FIELD OF THE DISPLAY. OTHERWISE, THE LAST 4 HEX 
;              DIGITS ARE DISPLAYED IN THE ADDRESS FIELD OF THE 
;              DISPLAY. IN EITHER CASE, A DOT WILL BE DISPLAYED AT THE
;              RIGHTMOST EDGE OF THE FIELD. A CHARACTER WHICH IS NOT 
;              A HEX DIGIT TERMINATES THE STRING AND IS RETURNED AS 
;              AN OUTPUT OF THE FUNCTION. IF THE TERMINATOR IS NOT 
;              A PERIOD OR A COMMA THEN ANY HEX DIGITS WHICH MAY HAVE 
;              BEEN RECEIVED ARE CONSIDERED TO BE INVALID. THE 
;              FUNCTION RETURNS A FLAG INDICATING WHETHER OR NOT ANY 
;              VALID HEX DIGITS WERE RECEIVED. 
; 
GTHEX: 
        MVI     C,0     ; RESET HEX DIGIT FLAG 
        PUSH    B       ; SAVE DISPLAY AND HEX DIGIT FLAGS
        LXI     D,0     ; SET HEX VALUE TO ZERO
        PUSH    D       ; SAVE HEX VALUE 
GTH05:
        CALL    RDKBD   ; READ KEYBOARD
        CPI     10H     ; IS CHARACTER A HEX DIGIT?
        JNC     GTH20   ; NO - GO CHECK FOR TERMINATOR 
                        ; YES - ARG - NEW HEX DIGIT IS IN A 
        POP     D       ; ARG - RETRIEVE HEX VALUE 
        CALL    INSDG   ; INSERT NEW DIGIT IN HEX VALUE 
        POP     B       ; RETRIEVE DISPLAY FLAG 
        MVI     C,1     ; SET HEX DIGIT FLAG 
                        ; /(I.E. A HEX DIGIT HAS BEEN READ) 
        PUSH    B       ; SAVE DISPLAY AND HEX DIGIT FLAGS 
        PUSH    D       ; SAVE HEX VALUE 
        MOV     A,B     ; TEST DISPLAY FLAG 
        RRC             ; SHOULD ADDRESS FIELD OF DISPLAY BE USED ? 
        JNC     GTH10   ; YES -U SE HEX VALUE AS IS 
                        ; NO - ONLY LOW ORDER BYTE OF HEX VALUE SHOULD 
                        ; /BE USED FOR DATA FIELD OF DISPLAY 
        MOV     D,E     ; PUT LOW ORDER BYTE OF HEX VALUE IN D 
GTH10:
                        ; ARG - HEX VALUE TO BE EXPANDED IS IN D , E 
        CALL    HXDSP   ; EXPAND HEX VALUE FOR DISPLAY 
                        ; ARG - ADDRESS OF EXPANDED HEX VALUE IN H , L 
        MOV     A,B     ; ARG - PUT DISPLAY FLAG IN A 
        MVI     B,DOT   ; ARG - DOT IN APPROPRIATE FIELD 
        CALL    OUTPT   ; OUTPUT HEX VALUE TO DISPLAY 
        JMP     GTH05   ; GO GET NEXT CHARACTER 
GTH20:                  ; LAST CHARACTER WAS NOT A HEX DIGIT 
        POP     D       ; RETRIEVE HEX VALUE 
        POP     B       ; RETRIEVE HEX DIGIT FLAG IN C 
        CPI     COMMA   ; WAS LAST CHARACTER ',' ?
        JZ      GTH25   ; YES - READY TO RETURN 
        CPI     PERIO   ; NO - WAS LAST CHARACTER '.' ? 
        JZ      GTH25   ; YES - READY TO RETURN 
                        ; NO - INVALID TERMINATOR - IGNORE ANY HEX DIGITS READ 
        LXI     D,0     ; SET HEX VALUE TO ZERO 
        JMP     RETF    ; RETURN FALSE 
GTH25: 
        MOV     B,A     ; SAVE LAST CHARACTER 
        MOV     A,C     ; SHIFT HEX DIGIT FLAG TO 
        RRC             ; /CARRY BIT 
        MOV     A,B     ; RESTORE LAST CHARACTER 
        RET             ; RETURN 
;
;********************************************************************
;
; FUNCTION: HXDSP - EXPAND HEX DIGITS FOR DISPLAY 
; INPUTS: DE - 4 HEX DIGITS 
; OUTPUTS: HL - ADDRESS OF OUTPUT BUFFER 
; CALLS: NOTHING 
; DESTROYS: A,H,L,F/F'S
; DESCRIPTION: HXDSP EXPANDS EACH INPUT BYTE TO 2 BYTES IN A FORM 
;              SUITABLE FOR DISPLAY BY THE OUTPUT ROUTINES. EACH INPUT 
;              BYTE IS DIVIDED INTO 2 HEX DIGITS. EACH HEX DIGIT IS 
;              PLACED IN THE LOW ORDER 4 BITS OF A BYTE WHOSE HIGH 
;              ORDER 4 BITS ARE SET TO ZERO. THE RESULTING BYTE IS 
;              STORED IN THE OUTPUT BUFFER. THE FUNCTION RETURNS THE 
;              ADDRESS OF THE OUTPUT BUFFER. 
;
HXDSP:
        MOV     A,D     ; GET FIRST DATA BYTE
        RRC             ; CONVERT 4 HIGH ORDER BITS
        RRC             ; /TO A SINGLE CHARACTER 
        RRC
        RRC
        ANI     0FH
        LXI     H,OBUFF ; GET ADDRESS OF OUTPUT BUFFER
        MOV     M,A     ; STORE CHARACTER IN OUTPUT BUFFER
        MOV     A,D     ; GET FIRST DATA BYTE AND CONVERT 4 LOW ORDER
        ANI     0FH     ; /BITS TO A SINGLE CHARACTER
        INX     H       ; NEXT BUFFER POSITION
        MOV     M,A     ; STORE CHARACTER IN BUFFER
        MOV     A,E     ; GET SECOND DATA BYTE
        RRC             ; CONVERT 4 HIGH ORDER BITS
        RRC             ; /TO A SINGLE CHARACTER
        RRC
        RRC
        ANI     0FH
        INX     H       ; NEXT BUFFER POSITION
        MOV     M,A     ; STORE CHARACTER IN BUFFER
        MOV     A,E     ; GET SECOND DATA BYTE AND CONVERT LOW ORDER
        ANI     0FH     ; /4 BITS TO A SINGLE CHARACTER
        INX     H       ; NEXT BUFFER POSITION
        MOV     M,A     ; STORE CHARACTER IN BUFFER
        LXI     H,OBUFF ; RETURN ADDRESS OF OUTPUT BUFFER IN H , L
        RET
;
;********************************************************************
;
; FUNCTION: ININT - INPUT INTERRUPT PROCESSING 
; INPUTS: NONE 
; OUTPUTS: NONE
; CALLS: NOTHING
; DESTROYS: NOTHING 
; DESCRIPTION: ININT IS ENTERED BY MEANS OF AN INTERRUPT VECTOR (IV2C) 
;              THEN THE READ KEYBOARD ROUTINE IS WAITING FOR A 
;              CHARACTER AND THE USER HAS PRESSED A KEY ON THE 
;              KEYBOARD (EXCEPT "RESET" OR  "VECTORED INTERRUPT"). 
;              ININT STORES THE INPUT CHARACTER IN THE INPUT BUFFER AND 
;              RETURNS CONTROL TO THE READ KEYBOARD ROUTINE. 
;
ININT:
        PUSH    H       ; SAVE H , L
        PUSH    PSW     ; SAVE F/F'S , REGISTER A 
        LXI     H,CNTRL ; ADDRESS FOR CONTROL CHARACTER OUTPUT
        MVI     M,READ  ; OUTPUT CONTROL CHARACTER FOR READING
                        ; /FROM KEYBOARD 
        DCR     H       ; ADDRESS FOR CHARACTER INPUT 
        MOV     A,M     ; READ A CHARACTER 
        ANI     3FH     ; ZERO 2 HIGH ORDER BITS 
        STA     IBUFF   ; STORE CHARACTER IN INPUT BUFFER 
        POP     PSW     ; RESTORE F/F'S, REGISTER A 
        POP     H       ; RESTORE H , L 
        RET
;
;********************************************************************
;
; FUNCTION: INSDG - INSERT HEX DIGIT 
; INPUTS: A - HEX DIGIT TO BE INSERTED 
;         DE - HEX VALUE 
; OUTPUTS: DE - HEX VALUE WITH DIGIT INSERTED 
; CALLS: NOTHING 
; DESTROYS: A,F/F'S 
; DESCRIPTION: INSDG SHIFTS THE CONTENTS OF D, E LEFT 4 BITS 
;              (1 HEX DIGIT) AND INSERTS THE HEX DIGIT IN A IN THE LOll 
;              ORDER DIGIT POSITION OF THE RESULT. A IS ASSUMED TO 
;              CONTAIN A SINGLE HEX DIGIT IN THE LOll ORDER 4 BITS AND 
;              ZEROS IN THE HIGH ORDER 4 BITS. 
; 
INSDG: 
        XCHG            ; PUT D & E IN H & L 
        DAD     H       ; SHIFT H , L LEFT 4 BITS 
        DAD     H 
        DAD     H 
        DAD     H 
        ADD     L       ; INSERT LOW ORDER DIGIT 
        MOV     L,A 
        XCHG            ; PUT H , L BACK IN D & E 
        RET 
;
;********************************************************************
;
; FUNCTION: NXTRG - ADVANCE REGISTER POINTER TO NEXT REGISTER 
; INPUTS: NONE 
; OUTPUTS: CARRY - 1 IF POINTER IS ADVANCED SUCCESSFULLY
;                - 0 OTHERWISE
; CALLS: NOTHING
; DESTROYS: A,F/F'S
; DESCRIPTION: IF THE REGISTER POINTER POINTS TO THE LAST REGISTER IN 
;              THE EXAMINE REGISTER SEQUENCE, THE POINTER IS NOT 
;              CHANGED AND THE FUNCTION RETURNS FALSE. IF THE REGISTER 
;              POINTER DOES NOT POINT TO THE LAST REGISTER THEN THE 
;              POINTER IS ADVANCED TO THE NEXT REGISTER IN THE SEQUENCE 
;              AND THE FUNCTION RETURNS TRUE. 
;
NXTRG: 
        LDA     RGPTR   ; GET REGISTER POINTER
        CPI     NUMRG-1 ; DOES POINTER POINT TO LAST REGISTER?
        JNC     RETF    ; YES - UNABLE TO ADVANCE POINTER - RETURN FALSE
        INR     A       ; NO - ADVANCE REGISTER POINTER
        STA     RGPTR   ; SAVE REGISTER POINTER
        JMP     RETT    ; RETURN TRUE 
;
;********************************************************************
;
; FUNCTION: OUTPT - OUTPUT CHARACTERS TO DISPLAY 
; INPUTS: A - DISPLAY FLAG - 0 = USE ADDRESS FIELD 
;                            1 = USE DATA FIELD 
;         B - DOT FLAG - 1 = OUTPUT DOT AT RIGHT EDGE OF FIELD 
;                        0 = NO DOT
;         HL - ADDRESS OF CHARACTERS TO BE OUTPUT 
; CALLS: NOTHING 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: OUTPT SENDS CHARACTERS TO THE DISPLAY. THE ADDRESS 
;              OF THE CHARACTERS IS RECEIVED AS AN ARGUMENT. EITHER 
;              2 CHARACTERS ARE SENT TO THE DATA FIELD, OR 4 CHARACTERS 
;              ARE SENT TO THE ADDRESS FIELD, DEPENDING ON THE 
;              DISPLAY FLAG ARGUMENT. THE DOT FLAG ARGUMENT DETERMINES 
;              WHETHER OR NOT A DOT (DECIMAL POINT) WILL BE SENT 
;              ALONG WITH THE LAST OUTPUT CHARACTER. 
;
OUTPT: 
        RRC             ; USE DATA FIELD ? 
        JC      OUT05   ; YES - GO SET UP TO USE DATA FIELD 
        MVI     C,4     ; NO -COUNT FOR ADDRESS FIELD 
        MVI     A,ADISP ; CONTROL CHARACTER FOR OUTPUT TO ADDRESS 
                        ; /FIELD OF DISPLAY 
        JMP     OUT10 
OUT05: 
        MVI     C,2     ; COUNT FOR DATA FIELD 
        MVI     A,DDISP ; CONTROL CHARACTER FOR OUTPUT TO DATA FIELD 
                        ; /OF DISPLAY 
OUT10: 
        STA     CNTRL 
OUT15: 
        MOV     A,M     ; GET OUTPUT CHARACTER 
        XCHG            ; SAVE OUTPUT CHARACTER ADDRESS IN D & E 
        LXI     H,DSPTB ; GET DISPLAY FORMAT TABLE ADDRESS 
        ADD     L       ; USE OUTPUT CHARACTER AS A POINTER TO 
        MOV     L,A     ; /DISPLAY FORMAT TABLE 
        MOV     A,M     ; GET DISPLAY FORMAT CHARACTER FROM TABLE 
        MOV     H,C     ; TEST COUNTER WITHOUT CHANGING IT 
        DCR     H       ; IS THIS THE LAST CHARACTER ? 
        JNZ     OUT20   ; NO - GO OUTPUT CHARACTER AS IS 
        DCR     B       ; YES - IS DOT FLAG SET ? 
        JNZ     OUT20   ; NO - GO OUTPUT CHARACTER AS IS 
        ORI     DTMSK   ; YES - OR IN MASK TO DISPLAY DOT WITH 
                        ; /LAST CHARACTER 
OUT20: 
        CMA             ; COMPLEMENT OUTPUT CHARACTER 
        STA     DSPLY   ; SEND CHARACTER TO DISPLAY 
        XCHG            ; RETRIEVE OUTPUT CHARACTER ADDRESS 
        INX     H       ; NEXT OUTPUT CHARACTER 
        DCR     C       ; ANY MORE OUTPUT CHARACTERS ? 
        JNZ     OUT15   ; YES - GO PROCESS ANOTHER CHARACTER 
        RET             ; NO - RETURN 
;
;********************************************************************
;
; FUNCTION: RDKBD - READ KEYBOARD 
; INPUTS: NONE 
; OUTPUTS: A - CHARACTER READ FROM KEYBOARD 
; CALLS: NOTHING 
; DESTROYS: A,H,L,F/F'S
; DESCRIPTION: RDKBD DETERMINES WHETHER OR NOT THERE IS A CHARACTER IN 
;              THE INPUT BUFFER. IF NOT, THE FUNCTION ENABLES 
;              INTERRUPTS AND LOOPS UNTIL THE INPUT INTERRUPT 
;              ROUTINE STORES A CHARACTER IN THE BUFFER. WHEN 
;              THE BUFFER CONTAINS A CHARACTER, THE FUNCTION FLAGS 
;              THE BUFFER AS EMPTY AND RETURNS THE CHARACTER 
;              AS OUTPUT. 
;
RDKBD: 
        LXI     H,IBUFF ; GET INPUT BUFFER ADDRESS 
        MOV     A,M     ; GET BUFFER CONTENTS 
                        ; HIGH ORDER BIT = 1 MEANS BUFFER IS EMPTY 
        ORA     A       ; IS A CHARACTER AVAILABLE ? 
        JP      RDK10   ; YES - EXIT FROM LOOP 
        EI              ; NO - READY FOR CHARACTER FROM KEYBOARD 
        JMP     RDKBD 
RDK10:
        MVI     M,EMPTY ; SET BUFFER EMPTY FLAG 
        DI              ; RETURN WITH INTERRUPTS DISABLED 
        RET 
;
;********************************************************************
;
; FUNCTION: RETF - RETURN FALSE 
; INPUTS: NONE 
; OUTPUTS: CARRY - 0 (FALSE) 
; CALLS: NOTHING 
; DESTROYS: CARRY 
; DESCRIPTION: RETF IS JUMPED TO BY FUNCTIONS WISHING TO RETURN FALSE. 
;              RETF RESETS CARRY TO 0 AND RETURNS TO THE CALLER OF 
;              THE ROUTINE INVOKING RETF. 
; 
RETF: 
        STC             ; SET CARRY TRUE 
        CMC             ; COMPLEMENT CARRY TO MAKE IT FALSE 
        RET 
;
;********************************************************************
;
; FUNCTION: RETT - RETURN TRUE 
; INPUTS: NONE 
; OUTPUTS: CARRY = 1 (TRUE) 
; CALLS: NOTHING 
; DESTROYS: CARRY 
; DESCRIPTION: RETT IS JUMPED TO BY ROUTINES WISHING TO RETURN TRUE. 
;              RETT SETS CARRY TO 1 AND RETURNS TO THE CALLER OF 
;              THE ROUTINE INVOKING RETT. 
; 
RETT: 
        STC             ; SET CARRY TRUE 
        RET 
;
;********************************************************************
;
; FUNCTION: RGLOC - GET REGISTER SAVE LOCATION 
; INPUTS: NONE 
; OUTPUTS: HL - REGISTER SAVE LOCATION 
; CALLS: NOTHING 
; DESTROYS: B,C,H,L,F/F'S 
; DESCRIPTION: RGLOC RETURNS THE SAVE LOCATION OF THE REGISTER 
;              INDICATED BY THE CURRENT REGISTER POINTER VALUE. 
; 
RGLOC: 
        LHLD    RGPTR   ; GET REGISTER POINTER 
        MVI     H,0     ; /IN H & L 
        LXI     B,RGTBL ; GET REGISTER SAVE LOCATION TABLE ADDRESS 
        DAD     B       ; POINTER INDEXES TABLE 
        MOV     L,M     ; GET LOW ORDER BYTE OF REGISTER SAVE LOC. 
        MVI     H, HIGH(RAMST) ; GET HIGH ORDER BYTE OF 
                        ; /REGISTER SAVE LOCATION 
        RET 
;
;********************************************************************
;
; FUNCTION: RGNAM - DISPLAY REGISTER NAME 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: OUTPT 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: RGNAM DISPLAYS, IN THE ADDRESS FIELD OF THE DISPLAY, 
;              THE REGISTER NAME CORRESPONDING TO THE CURRENT 
;              REGISTER POINTER VALUE. 
; 
RGNAM: 
        LHLD    RGPTR   ; GET REGISTER POINTER 
        MVI     H,0 
        DAD     H       ; MULTIPLY POINTER VALUE BY 4 
        DAD     H       ; /(REGISTER NAME TABLE HAS 4 BYTE ENTRIES) 
        LXI     B,NMTBL ; GET ADDRESS OF START OF REGISTER NAME TABLE 
        DAD     B       ; ARG - ADD TABLE ADDRESS TO POINTER - RESULT IS 
                        ; /ADDRESS OF APPROPRIATE REGISTER NAME IN H & L 
        XRA     A       ; ARG - USE ADDRESS FIELD OF DISPLAY 
        MVI     B,NODOT ; ARG - NO DOT IN ADDRESS FIELD 
        CALL    OUTPT   ; OUTPUT REGISTER NAME TO ADDRESS FIELD 
        RET 
;
;********************************************************************
;
; FUNCTION: RSTOR - RESTOR USER REGISTERS 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: NOTHING 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: RSTOR RESTORES ALL CPU REGISTERS, FLIP/FLOPS, 
;              INTERRUPT STATUS, INTERRUPT MASK, STACK POINTER 
;              AND PROGRAM COUNTER FROM THEIR RESPECTIVE 
;              SAVE LOCATIONS IN MEMORY. BY RESTORING THE PROGRAM 
;              COUNTER, THE ROUTINE EFFECTIVELY TRANSFERS CONTROL 'ro 
;              THE ADDRESS IN THE PROGRAM COUNTER SAVE LOCATION. 
; 
;              THE TIMING OF THIS ROUTINE IS CRITICAL TO THE 
;              CORRECT OPERATION OF THE SINGLE STEP ROUTINE. 
;              IF ANY MODIFICATION CHANGES THE NUMBER OF CPU 
;              STATES NEEDED TO EXECUTE THIS ROUTINE THEN THE 
;              TIMER VALUE MUST BE ADJUSTED BY THE SAME NUMBER. 
; 
; ***** THIS IS ALSO THE ENTRY POINT FOR THE TTY MONITOR 
;       TO RESTORE REGISTERS. 
;
RSTOR: 
        LDA     ISAV    ; GET USER INTERRUPT MASK 
        ORI     18H     ; ENABLE SETTING OF INTERRUPT MASK AND 
                        ; /RESET RST7.5 FLIP FLOP 
        SIM             ; RESTORE USER INTERRUPT MASK 
; RESTORE USER INTERRUPT STATUS 
        LDA     ISAV    ; GET USER INTERRUPT MASK 
        ANI     08H     ; SHOULD USER INTERRUPTS BE ENABLED ? 
        JZ      RSR05   ; NO - LEAVE INTERRUPTS DISABLED 
        EI              ; YES - ENABLE INTERRUPTS FOR USER PROGRAM 
        JMP     RSR10 
RSR05: 
        STC             ; DUMMY INSTRUCTIONS - WHEN SINGLE STEP ROUTINE 
        JNC     RSR10   ; /IS BEING USED, THE TIMER IS RUNNING AND
                        ; /EXECUTE TIME FOR THIS ROUTINE MUST NOT
                        ; /VARY. 
RSR10:
        LXI     H,MNSTK ; SET MONITOR STACK POINTER TO START OF STACK 
        SPHL            ; /WHICH IS ALSO END OF REGISTER SAVE AREA 
        POP     D       ; RESTORE REGISTERS 
        POP     B 
        POP     PSW 
        LHLD    SSAV    ; RESTORE USER STACK POINTER 
        SPHL 
        LHLD    PSAV 
        PUSH    H       ; PUT USER PROGRAM COUNTER ON STACK 
        LHLD    LSAV    ; RESTORE H & L REGISTERS 
        RET             ; JUMP TO USER PROGRAM COUNTER 
;
;********************************************************************
;
; FUNCTION: SETRG - SET REGISTER POINTER 
; INPUTS: NONE 
; OUTPUTS: CARRY - SET IF CHARACTER FROM KEYBOARD IS A REGISTER DESIGNATOR 
;                  RESET OTHERWISE 
; CALLS: RDKBD 
; DESTROYS: A,B,C,H,L,F/F'S 
; DESCRIPTION: SETRG READS A CHARACTER FROM THE KEYBOARD. IF THE 
;              CHARACTER IS A REGISTER DESIGNATOR, IT IS CONVERTED TO 
;              THE CORRESPONDING REGISTER POINTER VALUE, THE POINTER IS 
;              SAVED, AND THE FUNCTION RETURNS 'TRUE'. OTHERWISE, THE 
;              FUNCTION RETURNS 'FALSE'. 
; 
SETRG: 
        CALL    RDKBD   ; READ FROM KEYBOARD 
        CPI     10H     ; IS CHARACTER A DIGIT? 
        JNC     RETF    ; NO - RETURN FALSE - CHARACTER IS NOT A 
                        ; /REGISTER DESIGNATOR 
        SUI     3       ; YES - TRY TO CONVERT REGISTER DESIGNATOR TO 
                        ; / INDEX INTO REGISTER POINTER TABLE 
                        ; WAS CONVERSION SUCCESSFUL? 
        JC      RETF    ; NO - RETURN FALSE 
        MOV     C,A     ; INDEX TO B & C 
        MVI     B,0 
        LXI     H,RGPTB ; GET ADDRESS OF REGISTER POINTER TABLE 
        DAD     B       ; INDEX POINTS INTO TABLE 
        MOV     A,M     ; GET REGISTER POINTER FROM TABLE 
        STA     RGPTR   ; SAVE REGISTER POINTER 
        JMP     RETT    ; RETURN TRUE 
;
;********************************************************************
;
; FUNCTION: UPDAD - UPDATE ADDRESS FIELD OF DISPLAY 
; INPUTS: B - DOT FLAG - 1 MEANS PUT DOT AT RIGHT EDGE OF FIELD 
; 	                 0 MEANS NO DOT 
; OUTPUTS: NONE 
; CALLS: HXDSP,OUTPT 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: UPDAD UPDATES THE ADDRESS FIELD OF THE DISPLAY USING 
;              THE CURRENT ADDRESS. 
; 
UPDAD: 
        LHLD    CURAD   ; GET CURRENT ADDRESS 
        XCHG            ; ARG - PUT CURRENT ADDRESS IN D & E 
        CALL    HXDSP   ; EXPAND CURRENT ADDRESS FOR DISPLAY 
                        ; ARG - ADDRESS OF EXPANDED ADDRESS IS IN H & L 
        XRA     A       ; ARG - USE ADDRESS FIELD OF DISPLAY 
                        ; ARG - DOT FLAG IS IN B
        CALL    OUTPT   ; OUTPUT CURRENT ADDRESS TO ADDRESS FIELD
        RET 
;
;********************************************************************
;
; FUNCTION: UPDDT - UPDATE DATA FIELD OF DISPLAY 
; INPUTS: B - DOT FLAG - 1 MEANS PUT DOT AT RIGHT EDGE OF FIELD 
;                        0 MEANS NO DOT 
; OUTPUTS: NONE 
; CALLS: HXDSP,OUTDT 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: UPDDT UPDATES THE DATA FIELD OF THE DISPLAY USING 
;              THE CURRENT DATA BYTE. 
; 
UPDDT: 
        LDA     CURDT   ; GET CURRENT DATA 
        MOV     D,A     ; ARG - PUT CURRENT DATA IN D 
        CALL    HXDSP   ; EXPAND CURRENT DATA FOR DISPLAY 
                        ; ARG - ADDRESS OF EXPANDED DATA IS IN H , L 
        MVI     A,DTFLD ; ARG - USE DATA FIELD OF DISPLAY 
                        ; ARG - DOT PLAG IS IN B 
        CALL    OUTPT   ; OUTPUT CURRENT DATA TO DATA FIELD 
        RET 
;
;********************************************************************
;
;                       MONITOR TABLES 
;
;********************************************************************
;
; COMMAND TABLE 
;   COMMAND CHARACTERS AS RECEIVED FROM KEYBOARD 
CMDTB: 
        DB      12H     ; GO COMMAND 
        DB      13H     ; SUBSTITUTE MEMORY COMMAND 
        DB      14H     ; EXAMINE REGISTERS COMMAND 
        DB      15H     ; SINGLE STEP COMMAND 
NUMC    EQU     $-CMDTB ; NUMBER OF COMMANDS 
;
;********************************************************************
;
; COMMAND ROUTINE ADDRESS TABLE 
; (MUST BE IN REVERSE ORDER OF COMMAND TABLE) 
CMDAD: 
        DW      SSTEP   ; ADDRESS OF SINGLE STEP ROUTINE 
        DW      EXAM    ; ADDRESS OF EXAMINE REGISTERS ROUTINE 
        DW      SUBST   ; ADDRESS OF SUBSTITUTE MEMORY ROUTINE 
        DW      GOCMD   ; ADDRESS OF GO ROUTINE 
;
;********************************************************************
;
DSPTB:  ; TABLE FOR TRANSLATING CHARACTERS FOR OUTPUT 
; 
;               DISPLAY 
;               FORMAT CHARACTER 
;               ====== ========= 
; 
ZERO    EQU     $ - DSPTB 
        DB      0F3H    ; 0
        DB       60H    ; 1 
        DB      0B5H    ; 2 
        DB      0F4H    ; 3 
        DB       66H    ; 4 
FIVE    EQU     $ - DSPTB 
LETRS   EQU     $ - DSPTB 
        DB      0D6H    ; 5 AND S 
        DB      0D7H    ; 6 
        DB       70H    ; 7 
EIGHT   EQU     $ - DSPTB 
        DB      0F7H    ; 8 
        DB       76H    ; 9 
LETRA   EQU     $ - DSPTB 
        DB       77H    ; A 
LETRB   EQU     $ - DSPTB 
        DB      0C7H    ; B (LOWER CASE) 
LETRC   EQU     $ - DSPTB 
        DB       93H    ; C 
LETRD   EQU     $ - DSPTB 
        DB      0E5H    ; D (LOWER CASE) 
LETRE   EQU     $ - DSPTB 
        DB       97H    ; E 
LETRF   EQU     $ - DSPTB 
        DB       17H    ; F 
LETRH   EQU     $ - DSPTB 
        DB       67H   ; H 
LETRL   EQU     $ - DSPTB 
        DB       83H    ; L 
LETRP   EQU     $ - DSPTB 
        DB       37H    ; P 
LETRI   EQU     $ - DSPTB 
        DB       60H    ; I 
LETRR   EQU     $ - DSPTB 
        DB       05H    ; R (LOWER CASE) 
BLANK   EQU     $ - DSPTB 
        DB       00H    ; BLANK 
;
;********************************************************************
;
; MESSAGES FOR OUTPUT TO DISPLAY 
; 
BLNKS:  DB      BLANK,BLANK,BLANK,BLANK ; FOR ADDRESS OR DATA FIELD 
ERMSG:  DB      BLANK,LETRE,LETRR,LETRR ; ERROR MESSAGE FOR ADDR. FIELD 
EXMSG:  DB      LETRE,BLANK,BLANK,BLANK ; EXECUTION MESSAGE 
                                        ; /FOR ADDRESS FIELD 
SGNAD:  DB      BLANK,BLANK,EIGHT,ZERO  ; SIGN ON MESSAGE (ADDR. FIELD) 
SGNDT:  DB      EIGHT,FIVE              ; SIGN ON MESSAGE (DATA FIELD) 
;
;********************************************************************
;
RGPTB:      ; REGISTER POINTER TABLE 
            ; THE ENTRIES IN THIS TABLE ARE IN THE SAME ORDER 
            ; AS THE REGISTER DESIGNATOR KEYS ON THE KEYBOARD. 
            ; EACH ENTRY CONTAINS THE REGISTER POINTER VALUE WHICH 
            ; CORRESPONDS TO THE REGISTER DESIGNATOR. REGISTER 
            ; POINTER VALUES ARE USED TO POINT INTO THE REGISTER 
            ; NAME TABLE (NMTBL) AND REGISTER SAVE LOCATION 
            ; TABLE (RGTBL).
; 
        DB      6       ; INTERRUPT MASK 
        DB      9       ; SPH 
        DB      10      ; SPL 
        DB      11      ; PCR 
        DB      12      ; PCL 
        DB      7       ; H 
        DB      8       ; L 
        DB      0       ; A 
        DB      1       ; B 
        DB      2       ; C 
        DB      3       ; D 
        DB      4       ; E 
        DB      5       ; FLAGS 
;
;********************************************************************
;
NMTBL:              ; REGISTER NAME TABLE 
                    ; NAMES OF REGISTERS IN DISPLAY FORMAT
        DB      BLANK,BLANK,BLANK,LETRA ; A REGISTER 
        DB      BLANK,BLANK,BLANK,LETRB ; B REGISTER 
        DB      BLANK,BLANK,BLANK,LETRC ; C REGISTER 
        DB      BLANK,BLANK,BLANK,LETRD ; D REGISTER 
        DB      BLANK,BLANK,BLANK,LETRE ; E REGISTER 
        DB      BLANK,BLANK,BLANK,LETRF ; FLAGS 
        DB      BLANK,BLANK,BLANK,LETRI ; INTERRUPT MASK 
        DB      BLANK,BLANK,BLANK,LETRH ; H REGISTER 
        DB      BLANK,BLANK,BLANK,LETRL ; L REGISTER 
        DB      BLANK,LETRS,LETRP,LETRH ; STACK POINTER HIGH ORDER BYTE 
        DB      BLANK,LETRS,LETRP,LETRL ; STACK POINTER LOW ORDER BYTE 
        DB      BLANK,LETRP,LETRC,LETRH ; PROGRAM COUNTER HIGH BY'I'E 
        DB      BLANK,LETRP,LETRC,LETRL ; PROGRAM COUNTER LOW BYTE 
;
;********************************************************************
;
; REGISTER SAVE LOCATION TABLE 
; ADDRESSES OF SAVE LOCATIONS OF REGISTERS IN THE ORDER IN WHICH 
; THE REGISTERS ARE DISPLAYED BY THE EXAMINE COMMAND 
; 
RGTBL: 
        DB      ASAV AND 0FFH   ; A REGISTER 
        DB      BSAV AND 0FFH   ; B REGISTER 
        DB      CSAV AND 0FFH   ; C REGISTER 
        DB      DSAV AND 0FFH   ; D REGISTER 
        DB      ESAV AND 0FFH   ; E REGISTER 
        DB      FSAV AND 0FFH   ; FLAGS 
        DB      ISAV AND 0FFH   ; INTERRUPT MASK 
        DB      HSAV AND 0FFH   ; H REGISTER 
        DB      LSAV AND 0FFH   ; L REGISTER 
        DB      SPHSV AND 0FFH  ; STACK POINTER HIGH ORDER BYTE 
        DB      SPLSV AND 0FFH  ; STACK POINTER LOW ORDER BYTE 
        DB      PCLSV AND 0FFH  ; PROGRAM COUNTER HIGH ORDER BYTE 
        DB      PCLSV AND 0FFH  ; PROGRAM COUNTER LOW ORDER BYTE 
NUMRG   EQU     ($ - RGTBL)     ; NUMBER OF ENTRIES IN 
                                ; /REGISTER SAVE LOCATION TABLE 
;
;********************************************************************
;********************************************************************
;
;                       SDK-85 TTY MONITOR 
;
;********************************************************************
;********************************************************************
;
;
; ABSTRACT 
; ========
;
; THIS PROGRAM WAS ADAPTED, WITH FEW CHANGES, FROM THE SDK-80 MONITOR. 
; THIS PROGRAM RUNS ON THE 8885 BOARD AND IS DESIGNED TO PROVIDE 
; THE USER WITH A MINIMAL MONITOR. BY USING THIS PROGRAM, 
; THE USEa CAN EXAMINE AND tHANGE MEMORY OR CPU REGISTERS, LOAD 
; A PROGRAM (IN ABSOLUTE HEX) INTO RAM, AND EXECUTE INSTRUCTIONS 
; ALREADY IN MEMORY. THE MONITOR ALSO PROVIDES THE USER WITH 
; ROUTINES FOR PERFORMING CONSOLE I/O.
;
; 
; PROGRAM ORGANIZATION 
; ======= ============
;
; THE LISTING IS ORGANIZED IN THE FOLLOWING WAY. FIRST THE COMMAND 
; RECOGNIZER, WHICH IS THE HIGHEST LEVEL ROUTINE IN THE PROGRAM. 
; NEXT THE ROUTINES TO IMPLEMENT THE VARIOUS COMMANDS. FINALLY, 
; THE UTILITY ROUTINES WHICH ACTUALLY DO THE DIRTY WORK. WITHIN 
; EACH SECTION, THE ROUTINES ARE ORGANIZED IN ALPHABETICAL 
; ORDER, BY ENTRY POINT OF THE ROUTINE.
; 
; MACROS USED IN THE TTY MONITOR ARE DEFINED IN THE KEYBOARD MONITOR. 
;
; LIST OF FUNCTIONS 
; ==== == =========
;
;       GETCM
;       -----
; 
;       DCMD
;       GCMD
;       ICMD
;       MCMD
;       SCMD
;       XCMD 
;       ----
;       CI 
;       CNVBN 
;       CO 
;       CROUT 
;       DELAY 
;       ECHO 
;       ERROR 
;       FRET 
;       GETCH 
;       GETHX 
;       GETNM 
;       HILO 
;       NMOUT 
;       PRVAL 
;       REGDS 
;       RGADR 
;       SRET 
;       STHF0 
;       STHLF 
;       VALDG 
;       VALDL 
;       -----
;
;
;********************************************************************
;
;
;                       MONITOR EQUATES
;
;
;********************************************************************
;
;
BRCHR   EQU     1BH     ; CODE FOR BREAK CHARACTER (ESCAPE)
BRTAB   EQU     07FAH   ; LOCATION OF START OF BRANCH TABLE IN ROM
CR      EQU     0DH     ; CODE FOR CARRIAGE RETURN
ESC     EQU     1BH     ; CODE FOR ESCAPE CHARACTER
HCHAR   EQU     0FH     ; MASK TO SELECT LOWER HEX CHAR FROM BYTE
INVRT   EQU     0FFH    ; MASK TO INVSET HALF BYTE FLAG
LF      EQU     0AH     ; CODE FOR LINE FEED
LOWER   EQU     0       ; DENOTES LOWER HALF OF BYTE IN ICMD  
;LSGNON  EQU     ---     ; LENGTH OF SIGNON MESSAGE - DEFINED LATER
;MNSTK   EQU     ---     ; START OF  MONITOR  STACK  - DEFINED IN  
                        ; /KEYBOARD  MONITOR  
;NCMDS   EQU     ---     ; NUMBER OF VALID COMMANDS - DEFINED LATER  
NEWLN   EQU     0FH     ; MASK FOR CHECKING MEMORY ADDR DISPLAY
PRTY0   EQU     07FH    ; MASK TO CLEAR PARITY BIT FROM CONSOLE CHAR
;RAMST   EQU     ---     ; START ADDRESS OF RAM - DEFINED IN  
                        ; KEYBOARD  MONITOR  
;RTABS   EQU     ---     ; SIZE OF ENTRY IN RTAB TABLE 
SSTRT   EQU     80H     ; SHIFTED START BIT 
STOPB   EQU     40H     ; STOP BIT 
STRT    EQU     0C0H    ; UNSHIFTED START BIT 
TERM    EQU     1BH     ; CODE FOR ICMD TERMINATING CHARACTER (ESCAPE) 
UPPER   EQU     0FFH    ; DENOTES UPPER HALF OF BYTE IN ICMD
; 
; DELAY VALUES IF NO WAIT STATE 
;
;        IF      1-WAITS 
IBTIM   EQU     1164    ; INTER-BIT TIME DELAY 
OBTIM   EQU     1164    ; OUTPUT INTER-BIT TIME DELAY 
TIM4    EQU     4656    ; 4 BIT TIME DELAY 
WAIT    EQU     582     ; DELAY UNTIL READY TO SAMPLE BITS 
;        ENDIF 
; 
; DELAY VALUES IF ONE WAIT STATE 
;
;        IF      WAITS 
;IBTIM   EQU     930     ; INTER-BIT DELAY 
;OBTIM   EQU     930     ; OUTPUT INTER-BIT TIME DELAY 
;TIM4    EQU     3720    ; 4 BIT TIME DELAY 
;WAIT    EQU     465     ; DELAY UNTIL READY TO SAMPLE BITS 
;        ENDIF 
;
;
;********************************************************************
;
;
;               RESTART ENTRY POINT
;
;
;********************************************************************
;
;
;
;********************************************************************
;
;
;                       PRINT SIGNON MESSAGE
;
;
;********************************************************************
;
GO:
        LXI     H,SGNON ; GET ADDRESS OF SICNON MESSAGE
        MVI     B,LSGNON    ; COUNTER FOR CHARACTERS IN MESSAGE
MSGL:
        MOV     C,M     ; FETCH NEXT CHAR TO C REG
        CALL    CO      ; SEND IT TO THE CONSOLE
        INX     H       ; POINT TO NEXT CHARACTER
        DCR     B       ; DECREMENT BYTE COUNTER
        JNZ     MSGL    ; RETURN FOR NEXT CHARACTER
;
;
;********************************************************************
;
;
;               COMMAND RECOGNIZING ROUTINE
;
;
;********************************************************************
;
; FUNCTION: GETCM
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: GETCH,ECHO,ERROR
; DESTROYS: A,B,C,H,L,F/F'S
; DESCRIPTION: GETCM RECEIVES AN INPUT CHARACTER FROM THE USER
;              AND ATTEMPTS TO LOCATE THIS CHARACTER IN ITS COMMAND
;              CHARACTER TABLE.  IF SUCCESSFUL, THE ROUTINE
;              CORRESPONDING TO THIS CHARACTER IS SELECTED FROM
;              A TABLE OF COMMAND ROUTINE ADDRESSES, AND CONTROL
;              IS TRANSFERRED TO THIS ROUTINE. IF THE CHARACTER
;              DOES NOT MATCH ANY ENTRIES, CONTROL IS PASSED TO
;              THE ERROR HANDLER.
;
GETCM:
        LXI     H,MNSTK ; ALWAYS WANT TO RESET STACK PTR TO MONITOR
        SPHL            ; /STARTING VALUE SO ROUTINES NEEDN'T CLEAN UP
        MVI     C,'.'   ; PROMPT CHARACTER TO C
        CALL    ECHO    ; SEND PROMPT CHARACTER TO USER TERMINAL
        JMP     GTC03   ; WANT TO LEAVE ROOM FOR RST BRANCH
GTC03:
        CALL    GETCH   ; GET COMMAND CHARACTER TO A
        CALL    ECHO    ; ECHO CHARACTER TO USER
        MOV     A,C     ; PUT COMMAND CHARACTER INTO ACCUMULATOR
        LXI     B,NCMDS ; C CONTAINS LOOP AND INDEX COUNT
        LXI     H,CTAB  ; HL POINTS INT0 COMMAND TABLE
GTC05:
        CMP     M       ; COMPARE TABLE ENTRY AND CHARACTER
        JZ      GTC10   ; BRANCH IF EQUAL - COMMAND RECOGNIZED
        INX     H       ; ELSE, INCREMENT TABLE POINTER
        DCR     C       ; DECREMENT LOOP COUNT
        JNZ     GTC05   ; BRANCH IF NOT AT TABLE END
        JMP     ERROR   ; ELSE, COMMAND CHARACTER IS ILLEGAL
GTC10:
        LXI     H,CADR  ; IF GOOD COMMAND, LOAD ADDRESS OF TABLE
                        ; /OF COMMAND ROUTINE ADDRESSES
        DAD     B       ; ADD WHAT IS LEFT OF LOOP COUNT
        DAD     B       ; ADD AGAIN - EACH ENTRY IN CADR IS 2 DYTES LONG
        MOV     A,M     ; GET LSP OF ADDRESS OF TABLE ENTRY TO A
        INX     H       ; POINT TO NEXT BYTE IN TABLE
        MOV     H,M     ; GET MSP OF ADDRESS OF TABLE ENTRY TO H
        MOV     L,A     ; PUT LSP OF ADDRESS OF TABLE ENTRY INTO L
        PCHL            ; NEXT INSTRGCTION COMES FROM COMMAND ROUTINE
;
;
;********************************************************************
;
;
;                       COMMAND IMPLEMENTING ROUTINES
;
;
;********************************************************************
;
;
; FUNCTICN: DCMD
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: ECHO,NMOUT,HILO,GETCM,CROUT,GETNM
; DESTROYS: A,B,C,D,E,H,L,F/F'S
; DESCRIPTION: DCMD IMPLEMENTS THE DISPLAY MEMORY (D) COMMAND
;
DCMD:
        MVI     C,2     ; GET TWO NUMBERS FROM INPUT STREAM
        CALL    GETNM
        POP     D       ; ENDING ADDRESS TO DE
        POP     H       ; STARTING ADDRESS TO HL
DCM05:
        CALL    CROUT   ; ECHO CARRIAGE RETURN/LINE FEED
        MOV     A,H     ; DISPLAY ADDRESS OF FIRST LOCATION IN LINE
        CALL    NMOUT
        MOV     A,L     ; ADDRESS IS 2 BYTES LONG
        CALL    NMOUT
DCM10:
        MVI     C,' '
        CALL    ECHO    ; USE BLANK AS SEPARATOR
        MOV     A,M     ; GET CONTENTS OF NEXT MEMORY LOCATION
        CALL    NMOUT   ; DISPLAY CONTENTS
        CALL    HILO    ; SEE IF ADDRESS OF DISPLAYED LOCATION IS
                        ; /GREATER THAN OR EQUAL TO ENDING ADDRESS
; FALSE   DCM15   ; EXIT IF NO MORE TO DISPLAY
        JNC     DCM15
        CALL    CROUT   ; CARRIAGE RETURN/LINE FEED TO END LINE
        JMP     GETCM   ; ALL DONE
DCM15:
        INX     H       ; IF NONE TO GO, POINT TO NEXT LOC TO DISPLAY
        MOV     A,L     ; GET LOW ORDER BITS OF NEW ADDRESS
        ANI     NEWLN   ; SEE IF LAST HEX DIGIT OF ADDRESS DENOTES
                        ; /START OF NEW LINE
        JNZ     DCM10   ; NO - NOT AT END OF LINE
        JMP     DCM05   ; YES - START NEW LINE WITH ADDRESS
;
;
;********************************************************************
;
;
; FUNCTION: GCMD
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: ERROR,GETHX,RSTTF
; DESTROYS: A,B,C,D,E,H,L,F/F'S
; DESCRIPTION; GCMD IMPLEMENTS THE BEGIN EXECUTION (G) COMMAND
;
GCMD:
        CALL    GETHX   ; GET ADCRESS (IF PRESENT) FROM INPUT STREAM
;        FALSE   GCM05   ; BRANCH IF NO NGMBER PRESENT
        JNC     GCM05
        MOV     A,D     ; ELSE, GET TERMINATOR
        CPI     CR      ; SEE IF CARRIAGE RETURN
        JNZ     ERROR   ; ERROR IF NOT PROPERLY TERMINATED
        LXI     H,PSAV  ; WANT NUMBER TO REPLACE SAVE PGM COUNTER
        MOV     M,C
        INX     H
        MOV     M,B
        JMP     GCM10
GCM05:
        MOV     A,D     ; IF NO STARTING ADDRESS, MAKE SURE THAT
        CPI     CR      ; /CARRIAGE RETURN TERMINATED COMMAND
        JNZ     ERROR   ; ERROR IF NOT
GCM10:
        JMP     RSTOR   ; RESTORE REGISTERS AND BEGIN EXECUTION 
                        ; (RSTOR IS IN KEYBOARD MONITOR) 
;
;
;********************************************************************
;
;
; FUNCTION: ICMD
; INUTS: NONE
; OUTPUTS: NOE
; CALLS: ERROR,ECHO,GETCH,VALDL,VALDG,CNVBN,STHLF,GETNM,CROUT
; DESTROYS: A,B,C,D,E,H,L,F/F'S
; DESCRIPYION: ICMD IMPLEMENTS THE INSERT CODE INTO MEM0RY (I) COMMAND.
;
ICMD:
        MVI     C,1
        CALL    GETNM   ; GET SINGLE NUMBER FROM INPUT STREAM
        MVI     A,UPPER
        STA     TEMP    ; TEMP WILL HOLD THE UPPER/LOWER HALF BYTE FLAG
        POP     D       ; ADDRESS OF START TO DE
ICM05:
        CALL    GETCH   ; GET A CHARACTER FROM INPUT STREAM
        MOV     C,A
        CALL    ECHO    ; ECHO IT
        MOV     A,C     ; PUT CHARACTER BACK INTO A
        CPI     TERM    ;  SEE IF CHARACTER IS A TERMINATING CHARACTER
        JZ      ICM25   ; IF SO, ALL DONE ENTERING CHARACTERS
        CALL    VALDL   ; ELSE, SEE IF VALID DELIMITER
;        TRUE    ICM05   ; IF SO SIMPLY IGNORE THIS CHARACTER
        JC      ICM05
        CALL    VALDG   ; ELSE, CHECK TO SEE IF VALID HEX DIGIT
;        FALSE   ICM20   ; IF NOT, BRANCH TO HANDLE ERROR CONDITION
        JNC     ICM20
        CALL    CNVBN   ; CONVERT DIGIT TO BINARY
        MOV     C,A     ; MOVE RESULT TO C
        CALL    STHLF   ; STORE IN APPROPRIATE HALF WORD
        LDA     TEMP    ; GET HALF BYTE FLAG
        ORA     A       ; SET F/F'S
        JNZ     ICM10   ; BRANCH IF FLAG SET FOR UPPER
        INX     D       ; IF LOWER, INC ADDRESS OF BYTE TO STORE IN
ICM10:
        XRI     INVRT   ; TOGGLE STATE OF FLAG
        STA     TEMP    ; PUT NEW VALUE OF FLAG BACK
        JMP     ICM05   ; PROCESS NEXT DIGIT
ICM20:
        CALL    STHF0   ; ILLEGAL CHARACTER
        JMP     ERROR   ; MAKE SURE ENTIRE BYTE FILLED THEN ERROR
ICM25:
        CALL    STHF0   ; HERE FOR ESCAPE CHARACTER - INPUT IS DONE
        CALL    CROUT   ; ADD CARRIAGE RETURN
        JMP     GETCM
;
;
;********************************************************************
;
;
; FUNCTION: MCMD
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: GETCM,HILO,GETNM
; DESTROYS: A,B,C,D,E,H,L,F/F'S
; DESCRIPTION: MCMD IMPLEMENTS THE MOVE DATA IN MEMORY (M) COMMAND.
;
MCMD:
        MVI     C,3
        CALL    GETNM   ; GET 3 NUMBERS FROM INPUT STREAM
        POP     B       ; DESTIUATION ADDRESS TO BC
        POP     H       ; ENDING ADDRESS TO HL
        POP     D       ; STARTING ADDRESS TO DE
MCM05:
        PUSH    H       ; SAVE ENDING ADDRESS
        MOV     H,D
        MOV     L,E     ; SOURCE ADDEESS TO HL
        MOV     A,M     ; GET SOURCE BYTE
        MOV     H,B
        MOV     L,C     ; DESTINATICN ADDPESS TO BL
        MOV     M,A     ; MOVE BYTE TO DESTINATION
        INX     B       ; INCREMENT DESTINATION ADDRESS
        MOV     A,B
        ORA     C       ; TEST FOR DESTINATION ADDRESS OVERFLOW
        JZ      GETCM   ; IF SO, CAN TERMINATE COMMAND
        INX     D       ; INCREMENT SOURCE ADDRESS
        POP     H       ; ELSE, GET BACK ENDING ADDRESS
        CALL    HILO    ; SEE IF ENDING ADDR>=SOURCE ADDR
;        FALSE   GCTCM   ; IF NOT, COMMAND IS DONE
        JNC     GETCM
        JMP     MCM05   ; MOVE ANOTHER BYTE
;
;
;********************************************************************
;
;
; FUNCTION: SCMD
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: GETHX,GETCM,NMOUT,ECHO
; DESTROYS: A,B,C,D,E,H,L,F/F'S
; DESCRIPTION: SCMD IMPLEMENTS THE SUBSTITUTE INTO MEMORY (S) COMMAND.
;
SCMD:
        CALL    GETHX   ; GET A NUMBER, IF PRESENT, FROM INPUT
        PUSH    B
        POP     H       ; GET NUHBER TO HL - DENOTES MEMORY LOCATION
SCM05:
        MOV     A,D     ; GET TERMINATOR
        CPI     ' '     ; SEE IF SPACE
        JZ      SCM10   ; YES - CONTINUE PROCESSING
        CPI     ','     ; ELSE, SEE IF COMMA
        JNZ     GETCM   ; NO - TERMINATE COMMAND
SCM10:
        MOV     A,M     ; GET CONTENTS OF SPECIFIED LOCATION TO A
        CALL    NMOUT   ; DISPLAY CONTENTS ON CONSOLE
        MVI     C,'-'
        CALL    ECHO    ; USE DASH FOR SEPARATOR
        CALL    GETHX   ; GET NEW VALUE FOR MEMORY LOCATION, IF ANY
;        FALSE   SCM15   ; IF NO VALUE PRESCNT, BRANCH
        JNC     SCM15
        MOV     M,C     ; ELSE, STORE LOWER 8 BITS OF NUMBER ENTERED
SCM15:
        INX     H       ; INCREMENT ADDRESS OF MEMORY LOCATION TO VIEW
        JMP     SCM05;
;
;********************************************************************
;
;
; FUNCTION: XCMD
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: GETCH,ECHO,REGDS,GETCM,ERROR,RGADR,NMOUT,CROUT,GETHX
; DESTROYS: A,B,C,D,E,H,L,F/F'S
; DESCRIPTION: XCMD IMPLEMENTS THE REGISTER EXAMINE AND CHANGE (X)
;              COMMAND
;
XCMD:
        CALL    GETCH   ; GET REGISTER IDENTIFIER
        MOV     C,A
        CALL    ECHO    ; ECHO IT
        MOV     A,C
        CPI     CR
        JNZ     XCM05   ; BRANCH IF NOT CARRIACE RETURN 
        CALL    REGDS   ; ELSE, DISPLAY REGISTER CONTENTS
        JMP     GETCM   ; THEN TERMINATE COMMAND
XCM05:
        MOV     C,A     ; GET REGISTER IDENTIFIER TO C
        CALL    RGADR   ; CONVERT IDENTIFIER INTO RTAB TABLE ADDR
        PUSH    B
        POP     H       ; PUT POINTER TO REGISTER ENTRY INTO HL
        MVI     C,' '
        CALL    ECHO    ; ECHO SPACE TO USER
        MOV     A,C
        STA     TEMP    ; PUT SPACE INTO TEMP AS DELIMITER
XCM10:
        LDA     TEMP    ; GET TERMINATOR
        CPI     ' '     ; SEE IF A BLANK
        JZ      XCM15   ; YES - GO CHECK POINTER INTO TABLE
        CPI     ','     ; NO - SEE IF COMMA
        JNZ     GETCM   ; NO - MUST BE CARRIAGE RETURN TO END COMMAND
XCM15:
        MOV     A,M
        ORA     A       ; SET F/F'S
        JNZ     XCM18   ; BRANCH IF NOT AT END OF TABLE
        CALL    CROUT   ; ELSE, OUTPUT CARRIAGE RETURN LINEFEED
        JMP     GETCM   ; AND EXIT
XCM18:
        PUSH    H       ; PUT POINTER ON STACK
        MOV     E,M
        MVI     D, HIGH(RAMST) ; FETCH ADDRESS OF SAVE LOCATION FROM
        INX     H       ; /TABLE
        MOV     B,M     ; FETCH LENGTH FLAG FROM TABLE
        PUSH    D       ; SAVE ADDRESS OF SAVE LOCATION
        PUSH    D
        POP     H       ; MOVE ADDRESS TO HL
        PUSH    B       ; SAVE LENGHT FLAG
        MOV     A,M     ; GET 8 BITS OF REGISTER FROM SAVE LOCATION
        CALL    NMOUT   ; DISPLAY IT
        POP     PSW     ; GET BACK LENGTH FLAG
        PUSH    PSW     ; SAVE IT AGAIN
        ORA     A       ; SET F/F'S
        JZ      XCM20   ; IF 8 BIT REGISTER, NOTHING MORE TO DISPLAY
        DCX     H       ; ELSE FOR 16 BIT REGISTER, GET LOWER 8 BITS
        MOV     A,M
        CALL    NMOUT   ; DISPLAY THEM
XCM20:
        MVI     C,'-'
        CALL    ECHO    ; USE DASH AS SEPARATOR
        CALL    GETHX   ; SEE IF THERE IS A VALUE TO PUT INTO REGISTER
;        FALSE   XCM30   ; NO, GO CHECK FOR NEXT REGISTER
        JNC     XCM30
        MOV     A,D
        STA     TEMP    ; ELSE, SAVE THE TERMINATOR FOR NOW
        POP     PSW     ; GET BACK LENGTH FLAG
        POP     H       ; PUT ADDRESS OF SAVE LOCATION IN HL
        ORA     A       ; SET F/F'S
        JZ      XCM25   ; IF 8 BIT REGISTER, BRANCH
        MOV     M,B     ; SAVE UPPER 8 BITS
        DCX     H       ; POINT TO SAVE LOCATION FOR LOWER 8 BITS
XCM25:
        MOV     M,C     ; STORE ALL OF 8 BIT OR LOWER 1/2 OF 16 BIT REGISTER
XCM27:
        LXI     D,RTABS ; SIZE OF ENTRY IN RTAB TABLE
        POP     H       ; POINTER INTO REGISTER TABLE RTAB
        DAD     D       ; ADD ENTRY SIZE TO POINTER
        JMP     XCM10   ; DO NEXT REGISTER
XCM30:
        MOV     A,D     ; GET TERMINATOR
        STA     TEMP    ; SAVE IN MEMORY
        POP     D       ; CLEAR STACK OF LENGTH FLAG AND ADDRESS
        POP     D       ; /OF SAVE LOCATION
        JMP     XCM27   ; GO INCREMENT REGISTER TABLE POINTER
;
;
;********************************************************************
;
;
;                   UTILITY ROUTINES
;
;
;********************************************************************
;
;  
; FUNCTION: CI  
; INPUTS: NONE  
; OUTPUTS: A - CHARACTER FROM TTY  
; CALLS: DELAY  
; DESTROYS: A,F/F'S  
; DESCRIPTION: CI WAITS UNTIL A CHARACTER HAS BEEN ENTERED AT THE  
;              TTY AND THEN RETURNS THE CHARACTER, VIA THE A  
;              REGISTER, TO THE CALLING ROUTINE. THIS ROUTINE  
;              IS CALLED BY THE USER VIA A JUMP TABLE IN RAM.  
;
CI:  
        DI  
        PUSH    D       ; SAVE DE  
CI05:  
        RIM             ; GET INPUT BIT  
        RAL             ; INTO CARRY WITH IT  
        JC      CI05    ; BRANCH  IF  NO  START BIT
        LXI     D,WAIT  ; WAIT UNTIL MIDDLE OF BIT  
        CALL    DELAY  
        PUSH    B       ; SAVE BC  
        LXI     B,8     ; B<--0,  C<--# BITS TO RECEIVE  
CI10:  
        LXI     D,IBTIM  
        CALL    DELAY   ; WAIT UNTIL MIDDLE OF NEXT BIT  
        RIM             ; GET THE BIT  
        RAL             ; INTO  CARRY 
        MOV     A,B     ; GET PARTIAL RESULT  
        RAR             ; SHIFT IN NEXT DATA BIT  
        MOV     B,A     ; REPLACE RESULT  
        DCR     C       ; DEC COUNT OF BITS TO GO  
        JNZ     CI10    ; BRANCH IF MORE LEFT  
        LXI     D,IBTIM ; ELSE, WANT TO WAIT OUT STOP BIT  
        CALL    DELAY  
        MOV     A,B     ; GET RESULT  
        POP     B  
        POP     D       ; RESTORE SAVED REGISTERS  
        EI  
        RET             ; THAT'S IT  
;
;
;********************************************************************
;
;
; FUNCTION: CNVBN
; INPUTS: C - ASCII CHARACTER '0'-'9' OR 'A'-'F'
; OUTPUTS: A - 0 - F HEX
; CALLS: NOTHING
; DESTROYS: A,F/F'S
; DESCRIPTION: CNVBN CONVERTS THE ASCII REPRESENTATION OF A HEX
;              CHARACTER INTO ITS CORRESPONDING BINARY VALUE.  CNVBN
;              DOES NOT CHECK THE VALIDITY OF ITS INPUT.
;
CNVBN:
        MOV     A,C
        SUI     '0'     ; SUBTRACT CODE FOR '0' FROM ARGUMENT
        CPI     10      ; WANT TO TEST FOR RESULT 0 TO 9
        RM              ; IF SO, THEN ALL DONE
        SUI     7       ; ELSE, RESULT BETWEEN 17 AND 23 DECIMAL
        RET             ; SO RETURN AFTER SUBTRACTING BIAS OF 7
;
;
;********************************************************************
;
;
; FUNCTION: CO
; INPUTS: C - CHARACTER TO OUTPUT TO TTY
; OUTPUTS: C - CHARACTER OUTPUT TO TTY
; CALLS: DELAY
; DESTROYS: A,F/F'S
; DESCRIPTION: CO SENDS ITS ARGUMENT TO THE TTY
;
CO: 
        DI 
        PUSH    B       ; SAVE BC 
        PUSH    D       ; SAVE DE 
        MVI     A,STRT  ; START BIT MASK 
        MVI     B,7     ; B WILL COUNT BITS TO SEND
CO05: 
        SIM             ; SEND A BIT 
        LXI     D,OBTIM ; WAIT FOR TTY TO HANDLE IT 
        CALL    DELAY 
        MOV     A,C     ; PICK UP BITS LEFT TO SEND 
        RAR             ; LOW ORDER BIT TO CARRY 
        MOV     C,A     ; PUT REST BACK 
        MVI     A,SSTRT ; SHIFTED ENABLE BIT 
        RAR             ; SHIFT IN DATA BIT 
        XRI     80H     ; COMPLEMENT DATA BIT 
        DCR     B       ; DEC COUNT 
        JP      CO05    ; SEND IF MORE BITS NEED TO BE SENT 
        MVI     A,STOPB ; ELSE, SEND STOP BITS 
        SIM 
        LXI     D,TIM4  ; WAIT OUT PARITY BIT  
        CALL    DELAY  
        POP     D  
        POP     B       ; RESTORE SAVED REGISTERS  
        EI  
        RET             ; ALL DONE  
;
;
;********************************************************************
;
;
; FUNCTION: CROUT
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: ECHO
; DESTROYS: A,B,C,F/F'S
; DESCRIPTION: CROUT SENDS A CARRIAGE RETURN (AND HENCE A LINE
;              FEED) TO THE CONSOLE.
;
CROUT:
        MVI     C,CR
        CALL    ECHO    ; OUTPUT CARRIAGE RETURN TO USER TERMINAL
        RET
;
;
;********************************************************************
;
;
; FUNCTION DELAY
; INPUTS: DE - 16 BIT INTEGER DENOTING NUMBER OF TIMES TO LOOP
; OUTPUTS: NONE
; CALLS: NOTHING
; DESTROYS: A,D,E,F/F'S
; DESCRIPTION: DELAY DOES NOT RETURN TO CALLER UNTIL INPUT ARGUMENT
;              IS COUNTED DOWN TO 0.
;
DELAY:
        DCX     D       ; DECREMENT INPUT ARGUMENT
        MOV     A,D
        ORA     E 
        JNZ     DELAY   ; IF ARGUMENT NOT 0, KEEP GOING 
        RET
;
;
;********************************************************************
;
;
; FUNCTION: ECHO
; INPUTS: C - CHARACTER TO ECHO TO TERMINAL
; OUTPUTS: C - CHARACTER ECHOED TO TERMINAL
; CALLS: CO
; DESTROYS: A,B,,F/F'S
; DESCRIPTION: ECHO TAKES A SINGLE CHARACTER AS INPUT AND, VIA
;              THE MONITOR, SENDS THAT CHARACTER TO THE USER
;              TERMINAL.  A CARRIAGE RETURN IS ECHOED AS A CARRIAGE
;              RETURN LINE FEED, AND AN ESCAPE CHARACTER IS ECHOED AS $.
;
ECHO:
        MOV     B,C     ; SAVE ARGUMENT
        MVI     A,ESC
        CMP     B       ; SEE IF ECHOING AN ESCAPE CHARACTER
        JNZ     ECH05   ; NO - BRANCH
        MVI     C,'$'   ; YES - ECHO AS $
ECH05:
        CALL    CO      ; DO OUTPUT THROUGH MONITOR
        MVI     A,CR
        CMP     B       ; SEE IF CHARACTER ECHOED WAS A CARRIAGE RETURN
        JNZ     ECH10   ; NO - NO NEED TO TAKE SPECIAL ACTION
        MVI     C,LF    ; YES - WANT TO ECHO LINE FEED, TOO
        CALL    CO
ECH10:
        MOV     C,B     ; RESTORE ARGUMENT
        RET
;
;********************************************************************
;
;
; FUNCTION ERROR
; INPUTS: NONE
; OUTPUTS: NONE
; CALLS: ECHO,CROUT,GETCM
; DESTROYS: A,B,C,F/F'S
; DESCRIPTION: ERROR PRINTS 'THE ERROR CHARACTER (CURRENTLY AN ASTERISK)
;              ON THE CONSOLE, FOLLOWED BY A CARRIAGE RETURN-LINE FEED,
;              AND THEN RETURNS CONTROL TO THE COMMAND RECOGNIZER.
ERROR:
        MVI     C,'*'
        CALL    ECHO    ; SEND * TO CONSOLE
        CALL    CROUT   ; SKIP TO BEGINNING OF NEXT LINE
        JMP     GETCM   ; TRY AGAIN FOR ANOTHER COMMAND
;
;
;********************************************************************
;
;
; FUNCTION: FRET
; INOUTS: NONE
; OUTPUTS: CARRY - ALWAYS 0
; CALLS: NOTHING
; DESTROYS: CARRY
; DESCRIPTION: FRET IS JUMPED TO BY ANY ROUTINE THAT WISHES TO
;              INDICATE FAILURE ON RETURN. FRET SETS THE CARRY
;              FALSE, DENOTING FAILURE, AND THEN RETURNS TO THE
;              CALLER OF THE ROUTINE INVOKING FRET.
FRET:
        STC             ; FIRST SET CARRY TRUE
        CMC             ; THEN COMPLEMENT IT TO MAKE IT FALSE
        RET             ; RETURN APPROPRIATELY
;
;
;********************************************************************
;
;
; FUNCTION: GETCH
; INPUTS: NONE
; OUTPUTS: C - NEXT CHARACTER IN INPUT STREAM
; CALLS: CI
; DESTROYS: A,C,F/F'S
; DESCRIPTION: GETCH RETURNS THE NEXT CHARACTER IN THE INPUT STREAM
;              TO THE. CALLING PROGRAM.
GETCH:
        CALL    CI      ; GET CHARACTER FROM TERMINAL
        ANI     PRTY0   ; TURN OFF PARITY BIT IN CASE SET BY CONSOLE
        MOV     C,A     ; PUT VALUE IN C REGISTER FOR RETURN
        RET
;
;
;********************************************************************
;
;
; FUNCTION: GETHX
; INPUTS: NONE
; OUTPUTS: BC - 16 BIT INTEGER
;          D - CHARACTER WHICH TERMINATED THE INTEGER
;          CARRY - 1 IF FIRST CUARACTER NOT DELIMITER
;                - 0 IF FIRST CHARACTER IS DELIMITER
; CALLS: GETCH,ECHO,VALDL,VALDG,CNVBN,ERROR
; DESTROYS: A,B,C,D,E,F/F'S
; DESCRIPTION: GETHX ACCEPTS A STRING OF HEX DIGITS FROM THE INPUT
;              STREAM AND RETURNS THEIR VALUE AS A 16 BIT BINARY
;              INTEGER. IF MORE THAN 4 HEX DIGITS ARE ENTERED,
;              ONLY THE LAST 4 ARE USED. THE NUMBER TERMINATES WHEN
;              A VALID DELIMITER IS ENCOUNTERED. THE DELIMITER IS
;              ALSO RETURNED AS AN OUTPUT OF THE FUNCTION. ILLEGAL
;              CHARACTERS (NOT HEX DIGITS OR DELIMITERS) CAUSE AN
;              ERROR INDICATION. IF THE FIRST (VALID) CHARACTER
;              ENCOUNTERED IN THE INPUT STREAM IS NOT A DELIMITER,
;              GETHX WILL RETURN WITH THE CARRY BIT SET TO 1;
;              OTHERWISE, THE CARRY BIT IS SET TO 0 AND THE CONTENTS
;              OF BC ARE UNDEFINED.
;
GETHX: 
	PUSH 	H	; SAVE HL 
	LXI 	H,0	; INITIALIZE RESULT 
	MVI 	E,0	; INITIALIZE DIGIT FLAG TO FALSE 
GHX05: 
	CALL 	GETCH	; GET A CHARACTER 
	MOV     C,A
        CALL 	ECHO	; ECHO THE CHARACTER 
	CALL 	VALDL	; SEE IF DELIMITER 
	JNC 	GHX10	; NO - BRANCH 
	MOV 	D,C	; YES -ALL DONE, BUT WANT TO RETURN DELIMITER 
	PUSH 	H	; 
	POP 	B	; MOVE RESULT TO BC 
	POP 	H	; RESTORE HL 
	MOV 	A,E	; GET FLAG 
	ORA 	A	; SET F/F'S 
	JNZ 	SRET	; IF FLAG NON-0, A NUMBER HAS BEEN FOUND 
	JZ 	FRET	; ELSE, DELIMITER WAS FIRST CHARACTER 
GHX10: 
	CALL 	VALDG	; IF NOT DELIMITER, SEE IF DIGIT 
	JNC 	ERROR	; ERROR IF NOT A VALID DIGIT, EITHER 
	CALL 	CNVBN	; CONVERT DIGIT TO ITS BINARY VALUE 
	MVI 	E,00FFH	; SET DIGIT FLAG NON-0 
	DAD	H       ; *2
	DAD 	H       ; *4
	DAD 	H       ; *8
	DAD 	H       ; *16
	MVI 	B,0	; CLEAR UPPER 8 BITS OF BC PAIR 
	MOV 	C,A	; BINARY VALUE OF CHARACTER INTO C 
	DAD 	B	; ADD THIS VALUE TO PARTIAL RESULT 
	JMP 	GHX05	; GET NEXT CHARACTER 
;
;
;********************************************************************
;
;
; FUNCTION: GETNM 
; INPUTS: C - COUNT OF NUMBERS TO FIND IN INPUT STREAM 
; OUTPUTS: TOP OF STACK -NUMBERS FOUND IN REVERSE ORDER (LAST ON TOP 
;	   OF STACK) 
; CALLS: GETHX,HILO,ERROR 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: GETNM FINDS A SPECIFIED COUNT OF NUMBERS, BETWEEN 1 
; 	       AND 3, INCLUSIVE, IN THE INPUT 
; 	       STREAM AND RETURNS THEIR VALUES ON THE STACK. IF 2 
; 	       OR MORE NUMBERS ARE REQUESTED, THEN THE FIRST MUST BE 
; 	       LESS THAN OR EQUAL TO THE' SECOND, OR THE FIRST AND 
; 	       SECOND NUMBERS WILL BE SET EQUAL. THE LAST NUMBER 
; 	       REQUESTED MUST BE TERMINATED BY A CARRIAGE RETURN 
; 	       OR AN ERROR INDICATION WILL RESULT. 
; 
GETNM: 
	MVI 	L,3	; PUT MAXIMUM'ARGUMENT COUNT INTO L 
	MOV 	A,C	; GET THE ACTUAL ARGUMENT COUNT 
	ANI 	3	; FORCE TO MAXIMUM OF 3 
	RZ		; IF 0, DON'T BOTHER TO DO ANYTHIING 
	MOV 	H,A	; ELSE, PUT ACTUAL COUNT INTO H 
GNM05: 
	CALL 	GETHX	; GET A NUMBER FROM INPUT STREAM 
	JNC 	ERROR	; ERROR IF NOT THERE -TOO FEW NUMBERS 
	PUSH 	B	; ELSE, SAVE NUMBER ON STACK 
	DCR 	L	; DECREMENT MAXIMUM ARGUMENT COUNT 
	DCR 	H	; DECREMENT ACTUAL ARGUMENT COUNT 
	JZ 	GNM10	; BRANCH IF NO MORE NUMBERS WANTED 
	MOV 	A,D	; ELSE, GET NUMBER TERMINATOR TO A 
	CPI 	CR	; SEE IF CARRIAGE RETURN 
	JZ 	ERROR	; ERROR IF SO - TOO FEW NUMBERS 
	JMP 	GNM05	; ELSE, PROCESS NEXT NUMBER 
GNM10: 
	MOV 	A,D	; WHEN COUNT 0, CHECK LAST TERMINATOR 
	CPI 	CR	; 
	JNZ 	ERROR	; ERROR IF NOT CARRIAGE RETURN 
	LXI 	B,0FFFFH	; HL GETS LARGEST NUMBER 
	MOV 	A,L	; GET WHAT'S LEFT OF MAXIMUM ARG COUNT 
	ORA 	A	; CHECK FOR 0 
	JZ 	GNM20	; IF YES, 3 NUMBERS WERE INPUT 
GNM15: 
	PUSH 	B	; IF NOT, FILL REMAINING ARGUMENTS WITH 0FFFFH 
	DCR 	L
	JNZ 	GNM15
GNM20: 
	POP 	B	; GET THE 3 ARGUMENTS OUT 
	POP 	D
	POP 	H
	CALL 	HILO	; SEE IF FIRST >= SECOND 
	JNC 	GNM25	; NO - BRANCH 
	MOV 	D,H
	MOV 	E,L	; YES - MAKE SECOND EQUAL TO THE FIRST 
GNM25: 
	XTHL 		; PUT FIRST ON STACK -GET RETURN ADDR 
	PUSH 	D	; PUT SECOND ON STACK 
	PUSH 	B	; PUT THIRD ON STACK 
	PUSH 	H	; PUT RETURN ADDRESS ON STACK 
GNM30: 
	DCR 	A	; DECREMENT RESIDUAL COUNT 
	RM 		; IF NEGATIVE, PROPER RESULTS ON STACK 
	POP 	H	; ELSE, GET RETURN ADDR 
	XTHL 		; REPLACE TOP RESULT WITH RETURN ADDR 
	JMP 	GNM30	; TRY AGAIN
;
;
;********************************************************************
;
;
; FUNCTION: HILO 
; INPUTS: DE - 16 BIT INTEGER 
; 	  HL -16 BIT INTEGER 
; OUTPUTS: CARRY - 0 IF HL<DE 
; 	     	 - 1 IF HL>=DE 
; CALLS: NOTHING 
; DESTROYS: F/F'S 
; DESCRIPTION: HILO COMPARES THE 2 16 BIT INTEGERS IN HL AND DE. THE 
;	       INTEGERS ARE TREATED AS UNSIGNED NUMBERS. THE CARRY 
;	       BIT IS SET ACCORDING TO THE RESULT OF THE COMPARISON. 
; 
HILO:  
        PUSH    B       ; SAVE  BC  
        MOV     B,A     ; SAVE  A  IN  B REGISTER  
        PUSH    H       ; SAVE  HL  PAIR  
        MOV     A,D     ; CHECK  FOR  DE = 0000H  
        ORA     E  
        JZ      HIL05   ; WE'RE AUTOMATICALLY  DONE  IF IT  IS  
	INX 	H	; INCREMENT HL BY 1 
	MOV 	A,H	; WANT TO TEST FOR 0 RESULT AFTER 
	ORA 	L	; /INCREMENTING 
        JZ      HIL05   ; IF  SO,  HL  MUST  HAVE  CONTAINED  0FFFFH  
        POP     H       ; IF  NOT,  RESTORE  ORIGINAL  HL  
        PUSH    D       ; SAVE  DE  
        MVI     A,0FFH  ; WANT  TO  TAKE  2'S  COMPLEMENT  OF  DE  CONTENTS  
        XRA     D  
        MOV     D,A  
        MVI     A,0FFH  
        XRA     E  
        MOV     E,A  
        INX     D       ; 2'S  COMPLEMENT  OF  DE  TO  DE  
        MOV     A,L  
        ADD     E       ; ADD  HL  AND  DE  
        MOV     A,H  
        ADC     D       ; THIS  OPERATION  SETS  CARRY  PROPERLY  
        POP     D       ; RESTORE  ORIGINAL  DE  CONTENTS  
        MOV     A,B     ; RESTORE  ORIGINAL  CONTENTS  OF  A  
        POP     B       ; RESTORE  ORIGINAL  CONTENTS  OF  BC  
        RET             ; RETURN  WITH  CARRY  SET  AS  REQUIRED  
HIL05:  
        POP     H       ; IF  HL  CONTAINS  0FFFFH,  THEN  CARRY  CAN  
        MOV     A,B     ; /ONLY  BE  SET  TO  1  
        POP     B       ; RESTORE  ORIGINAL  CONTENTS  OF  REGISTERS  
        JMP     SRET    ; SET  CARRY  AND  RETURN  

;
;
;********************************************************************
;
;
; FUNCTION: NMOUT 
; INPUTS: A - 8 BIT INTEGER 
; OUTPUTS: NONE 
; CALLS: ECHO,PRVAL 
; DESTROYS: A,B,C,F/F'S 
; DESCRIPTION: NMOUT CONVERTS THE 8 BIT, UNSIGNED INTEGER IN THE 
;	       A REGISTER INTO 2 ASCII CHARACTERS. THE ASCII CHARACTERS 
; 	       ARE THE ONES REPRESENTING THE 8 BITS. THESE TWO 
; 	       CHARACTERS ARE SENT TO THE CONSOLE AT THE CURRENT PRINT 
;	       POSITION OF THE CONSOLE. 
; 
NMOUT: 
        PUSH    H       ; SAVE HL -DESTROYED BY PRVAL 
        PUSH    PSW     ; SAVE ARGUMENT 
        RRC 
        RRC 
        RRC 
        RRC             ; GET UPPER 4 BITS TO LOW 4 BIT POSITIONS 
        ANI     HCHAR   ; MASK OUT UPPER 4 BITS - WANT 1 HEX CHAR 
        MOV     C,A 
        CALL    PRVAL   ; CONVERT LOWER 4 BITS TO ASCII 
        CALL    ECHO    ; SEND TO TERMINAL 
        POP     PSW     ; GET BACK ARGUMENT 
        ANI     HCHAR   ; MASK OUT UPPER 4 BITS - WANT 1 HEX CHAR 
        MOV     C,A 
        CALL    PRVAL 
        CALL    ECHO 
        POP     H       ; RESTORE SAVED VALUE OF HL 
        RET 
;
;
;********************************************************************
;
;
; FUNCTION: PRVAL 
; INPUTS: A - INTEGER, RANGE 0 TO F 
; OUTPUTS: A - ASCII CHARACTER 
; CALLS: NOTHING 
; DESTROYS: B,C,H,L,F/F'S 
; DESCRIPTION: PRVAL CONVERTS A NUMBER IN THE RANGE 0 TO F HEX TO 
;	       THE CORRESPONDING ASCII CHARACTER, 0-9, A-F. PRVAL 
;	       DOES NOT CHECK THE VALIDITY OF ITS INPUT ARGUMENT. 
; 
PRVAL: 
        LXI     H,DIGTB ; ADDRESS OF TABLE 
        MVI     B,0     ; CLEAR HIGH ORDER BITS OF BC 
        DAD     B       ; ADD DIGIT VALUE TO HL ADDRESS 
        MOV     C,M     ; FETCH CHARACTER FROM MEMORY 
        RET 
;
;
;********************************************************************
;
;
; FUNCTION: REGDS 
; INPUTS: NONE 
; OUTPUTS: NONE 
; CALLS: ECHO,NMOUT,ERROR,CROUT 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: REGDS DISPLAYS THE CONTENTS OF THE REGISTER SAVE 
;	       LOCATIONS, IN FORMATTED FORM, ON THE CONSOLE. THE 
;	       DISPLAY IS DRIVEN FROM A TABLE, RTAB, WHICH CONTAINS 
;	       THE REGISTER'S PRINT SYMBOL, SAVE LOCATION ADDRESS, 
;	       AND LENGTH (8 OR 16 BITS).
; 
REGDS: 
        LXI     H,RTAB  ; LOAD HL WITH ADDRESS OF START OF TABLE 
REG05: 
        MOV     C,M     ; GET PRINT SYMBOL OF REGISTER 
        MOV     A,C 
        ORA     A       ; TEST FOR 0 -END OF TABLE 
        JNZ     REG10   ; IF NOT END, BRANCH 
        CALL    CROUT   ; ELSE, CARRIAGE RETURN/LINE FEED TO END 
        RET             ; /DISPLAY 
REG10: 
        CALL    ECHO    ; ECHO CHARACTER 
        MVI     C,'=' 
        CALL    ECHO    ; OUTPUT EQUALS SIGN, I.E. A = 
        INX     H       ; POINT TO START OF SAVE LOCATION ADDRESS 
        MOV     E,M     ; GET LSP OF SAVE LOCATION ADDRESS TO E 
        MVI     D, HIGH(RAMST); PUT MSP OF SAVE LOC ADDRESS INTO 0 
        INX     H       ; POINT TO LENGTH FLAG 
        LDAX    D       ; GET CONTENTS OF SAVE ADDRESS 
        CALL    NMOUT   ; DISPLAY ON CONSOLE 
        MOV     A,M     ; GET LENGTH FLAG 
        ORA     A       ; SET SIGN F/F 
        JZ      REG15   ; IF 0, REGISTER IS 8 BITS
        DCX     D       ; ELSE, 16 BIT REGISTER SO MORE TO DISPLAY 
        LDAX    D       ; GET LOWER 8 BITS 
        CALL    NMOUT   ; DISPLAY THEM 
REG15: 
        MVI     C,' '
        CALL    ECHO	; OUTPUT BLANK CHARACTER 
        INX     H       ; POINT TO START OF NEXT TABLE ENTRY 
        JMP     REG05   ; DO NEXT REGISTER 
;
;
;********************************************************************
;
;
; FUNCTION: RGADR 
; INPUTS: C - CHARACTER DENOTING REGISTER 
; OUTPUTS: BC - ADDRESS OF ENTRY IN RTAB CORRESPONDING TO REGISTER 
; CALLS: ERROR 
; DESTROYS: A,B,C,D,E,H,L,F/F'S 
; DESCRIPTION: RGADR TAKES A SINGLE CHARACTER AS INPUT. THIS CHARACTER 
;	       DENOTES A REGISTER. RGADR SEARCHES THE TABLE RTAB 
;	       FOR A MATCH ON THE INPUT ARGUMENT. IF ONE OCCURS, 
;	       RGADR RETURNS THE ADDRESS OF THE ADDRESS OF THE 
;	       SAVE LOCATION CORRESPONDING TO THE REGISTER. THIS 
;	       ADDRESS POINTS INTO RTAB. IF NO MATCH OCCURS, THEN 
;	       THE REGISTER IDENTIFIER IS ILLEGAL AND CONTROL IS 
;	       PASSED TO THE ERROR ROUTINE. 
; 
RGADR: 
	LXI 	H,RTAB	; HL GETS ADDRESS OF TABLE START
	LXI 	D,RTABS	; DE GET SIZE OF A TABLE ENTRY 
RGA05: 
	MOV 	A,M	; GET REGISTER IDENTIFIER
	ORA 	A	; CHECK FOR TABLE END (IDENTIFIER IS (0) 
	JZ 	ERROR	; IF AT END OF TABLE, ARGUMENT IS ILLEGAL
	CMP 	C	; ELSE, COMPARE TABLE ENTRY AND ARGUMENT
	JZ 	RGA10	; IF EQUAL, WE'VE FOUND WHAT WE'RE LOOKING FOR
	DAD 	D	; ELSE, INCREMENT TABLE POINTER TO NEXT ENTRY
	JMP 	RGA05	; TRY AGAIN
RGA10: 
	INX 	H	; IF A MATCH, INCREMENT TABLE POINTER TO
	MOV 	B,H	; /SAVE LOCATION ADDRESS
	MOV 	C,L	; RETURN THIS VALUE 
	RET
;
;
;********************************************************************
;
;
; FUNCTION: SRET 
; INPUTS: NONE 
; OUTPUTS: CARRY = 1 
; CALLS: NOTHING 
; DESTROYS: CARRY 
; DESCRIPTION: SRET IS JUMPED TO BY ROUTINES WISHING TO RETURN SUCCESS. 
;	       SRET SETS THE CARRY TRUE AND THEN RETURNS TO THE 
;	       CALLER OF THE ROUTINE INVOKING SRET. 
; 
SRET: 
	STC		; SET CARRY TRUE 
	RET		; RETURN APPROPRIATELY 
;
;
;********************************************************************
;
;
; FUNCTION: STHF0 
; INPUTS: DE - 16 BIT ADDRESS OF BYTE TO BE STORED INTO 
; OUTPUTS: NONE 
; CALLS: NOTHING 
; DESTROYS: A,B,C,H,L,F/F'S 
; DESCRIPTION: STHF0 CHECKS THE HALF BYTE FLAG IN TEMP TO SEE IF 
;	       IT IS SET TO LOWER. IF SO, STHF0 STORES A 0 TO 
;	       PAD OUT THE LOWER HALF OF THE ADDRESSED BYTE 
;	       OTHERWISE, THE ROUTINE TAKES NO ACTION. 
; 
STHF0: 
	LDA 	TEMP	; GET HALF BYTE FLAG 
	ORA 	A	; SET F/F'S 
	RNZ		; IF SET TO UPPER, DON'T DO ANYTHING 
	MVI 	C,0	; ELSE, WANT TO STORE THE VALUE 0 
	CALL 	STHLF	; DO IT 
	RET
;
;
;********************************************************************
;
;
; FUNCTION: STHLF 
; INPUTS: C - 4 BIT VALUE TO BE STORED IN HALF BYTE 
; 	  DE - 16 BIT ADDRESS OF BYTE TO BE STORED INTO 
; OUTPUTS: NONE 
; CALLS: NOTHING 
; DESTROYS: A,B,C,H,L,F/F'S 
; DESCRIPTION: STHLF TAKES THE 4 BIT VALUE IN C AND STORES IT IN 
;	       HALF OF THE BYTE ADDRESSED BY REGISTERS DE. THE 
;	       HALF BYTE USED (EITHER UPPER OR LOWER) IS DENOTED 
;	       BY THE VALUE OF THE FLAG IN TEMP. STHLF ASSUMES 
;	       THAT THIS FLAG HAS BEEN PREVIOUSLY SET 
;	       (NOMINALLY BY ICMD). 
; 
STHLF: 
	PUSH 	D
	POP 	H	; MOVE ADDRESS OF BYTE INTO HL 
	MOV 	A,C	; GET VALUE 
	ANI 	0FH	; FORCE TO 4 BIT LENGTH 
	MOV 	C,A	; PUT VALUE BACK 
	LDA 	TEMP	; GET HALF BYTE FLAG 
	ORA 	A	; CHECK FOR LOWER HALF 
	JNZ 	STH05	; BRANCH IF NOT 
	MOV 	A,M	; ELSE, GET BYTE 
	ANI 	0F0H	; CLEAR LOWER 4 BITS 
	ORA 	C	; OR IN VALUE 
	MOV 	M,A	; PUT BYTE BACK 
	RET
STH05: 
	MOV 	A,M	; IF UPPER HALF, GET BYTE 
	ANI 	0FH	; CLEAR UPPER 4 BITS 
	MOV 	B,A	; SAVE BYTE IN B 
	MOV 	A,C	; GET VALUE 
	RRC
	RRC
	RRC
	RRC 		; ALIGN TO UPPER 4 BITS 
	ORA 	B	; OR IN ORIGINAL LOWER 4 BITS 
	MOV 	M,A	; PUT NEW CONFIGURATION BACK 
	RET
;
;
;********************************************************************
;
;
; FUNCTION: VALDG 
; INPUTS: C - ASCII CHARACTER 
; OUTPUTS: CARRY - 1 IF CHARACTER REPRESENTS VALID HEX DIGIT 
;	         - 0 OTHERWISE 
; CALLS: NOTHING 
; DESTROYS: A,F/F'S 
; DESCRIPTION: VALDG RETURNS SUCCESS IF ITS INPUT ARGUMENT IS 
;	       AN ASCII CHARACTER REPRESENTING A VALID HEX DIGIT 
;	       (0-9,A-F), AND FAILURE OTHERWISE. 
; 
VALDG: 
	MOV 	A,C
	CPI 	'0'	; TEST CHARACTER AGAINST '0' 
	JM 	FRET	; IF ASCII CODE LESS, CANNOT BE VALID DIGIT 
	CPI 	'9'	; ELSE, SEE IF IN RANGE '0'-'9' 
	JM 	SRET	; CODE BETWEEN '0' AND '9' 
	JZ 	SRET	; CODE EQUAL '9' 
	CPI 	'A'	; NOT A DIGIT - TRY FOR A LETTER 
	JM 	FRET	; NO - CODE BETWEEN '9' AND 'A' 
	CPI 	'G'
	JP 	FRET	; NO - CODE GREATER THAN 'F' 
	JMP 	SRET	; OKAY - CODE IS 'A' TO 'F', INCLUSIVE 
;
;
;********************************************************************
;
;
; FUNCTION: VALDL 
; INPUTS: C - CHARACTER 
; OUTPUTS: CARRY - 1 IF INPUT ARGUMENT VALID DELIM'fER 
; 	     	 - 0 OTHERWISE 
; CALLS: NOTHING 
; DESTROYS: A,F/F'S 
; DESCRIPTION: VALDL RETURNS SUCCESS IF ITS INPUT ARGUMENT IS A VALID 
;	       DELIMITER CHARACTER (SPACE, COMMA, CARRIAGE RETURN, 
;	       AND LINE FEED) FAILURE OTHERWISE. 
; 
VALDL: 
	MOV 	A,C	
	CPI 	','	; CHECK FOR COMMA 
	JZ 	SRET
	CPI 	CR	; CHECK FOR CARRIAGE RETURN 
	JZ 	SRET
	CPI 	' '	; CHECK FOR SPACE 
	JZ 	SRET
	JMP 	FRET	; ERROR IF NONE OF THE ABOVE 
;
;
;********************************************************************
;
;
;                           MONITOR TABLES
;
;
;********************************************************************
;
;
SGNON: 	                ; SIGNON MESSAGE 
        DB      CR,LF,'SDK-85   VER 2.1',CR,LF 
LSGNON 	EQU 	$-SGNON	; LENGTH OF SIGNON MESSAGE 
; 
CADR: 			; TABLE OF ADDRESSES OF COMMAND ROUTINES 
	DW 	0	; DUMMY 
	DW 	XCMD
	DW 	SCMD
	DW 	MCMD
	DW 	ICMD
	DW 	GCMD
	DW 	DCMD
; 
CTAB: 			; TABLE OF VALID COMMAND CHARACTERS 
	DB 	'D'
	DB 	'G'
	DB 	'I'
	DB 	'M'
	DB 	'S'
	DB 	'X'
NCMDS 	EQU 	$-CTAB	; NUMBER OF VALID COMMANDS 
;  
DIGTB:                  ; TABLE  OF  PRINT  VALUES  OF  HEX  DIGITS  
        DB      '0'  
        DB      '1'  
        DB      '2'  
        DB      '3' 
        DB      '4' 
        DB      '5'  
        DB      '6'  
        DB      '7'  
        DB      '8'  
        DB      '9'  
        DB      'A'  
        DB      'B'  
        DB      'C'  
        DB      'D'  
        DB      'E'  
        DB      'F'  
;
; 
RTAB:			; TABLE OF REGISTER INFORMATION 
	DB 	'A'	; REGISTER IDENTIFIER 
	DB 	ASAV AND 0FFH	; ADDRESS OF REGISTER SAVE LOCATION 
	DB 	0 	; LENGTH FLAG - 0=8 BITS, 1=16 BITS 
RTABS 	EQU 	$-RTAB	; SIZE OF AN ENTRY IN THIS TABLE 
	DB 	'B'
	DB 	BSAV AND 0FFH
	DB 	0
	DB 	'C'
	DB 	CSAV AND 0FFH
	DB 	0	
	DB 	'D'
	DB 	DSAV AND 0FFH
	DB 	0
	DB 	'E'
	DB 	ESAV AND 0FFH
	DB 	0
	DB 	'F'
	DB 	FSAV AND 0FFH
	DB 	0
	DB 	'I'
	DB 	ISAV AND 0FFH
	DB 	0
	DB 	'H'
	DB 	HSAV AND 0FFH
	DB 	0
	DB 	'L'
	DB 	LSAV AND 0FFH
	DB 	0
	DB 	'M'
	DB 	HSAV AND 0FFH
	DB 	1
	DB 	'S'
	DB 	SSAV+1 AND 0FFH
	DB 	1
	DB 	'P'
	DB 	PSAV+1 AND 0FFH
	DB 	1
	DB 	0	; END OF TABLE MARKERS 
	DB 	0 
; 
        ORG     BRTAB
;
        JMP     CO      ; BRANCH TABLE FOR USER ACCESSIBLE ROOTINES
        JMP     CI
; ****************************************************************
;
; IN THE FOLLOWING LOCATIONS, THE USER MAY PLACE JUMP INSTRUCTIONS TO  
; ROUTINES FOR HANDLING THE FOLLOWING:  
;       A) RST 5,6 & 7 INSTRUCTIONS  
;       B) HARDWIRED USER INTERRUPT (RST 6.5)  
;       C) KEYBOARD "VECTORED INTERRUPT" KEY (RST 7.5)  
; 
        ORG     USRBR   ; START OF USER BRANCH LOCATIONS  
;  
RSET5:  DB      0,0,0   ; JUMP TO RST 5 ROUTINE  
RSET6:  DB      0,0,0   ; JUMP TO RST 6 ROUTINE  
RST65:  DB      0,0,0   ; JUMP TO RST 6.5 (HARDWIRED USER INTERRUPT)  
RSET7:  DB      0,0,0   ; JUMP TO RST 7 ROUTINE  
USINT:  DB      0,0,0   ; JUMP TO "VECTORED INTERRUPT" KEY ROUTINE  
;
; ****************************************************************
;
; SPACE IS RESERVED HERE FOR THE MONITOR STACK  
;
; ****************************************************************
;
        ORG     MNSTK   ; START OF MONITOR STACK  
;
; SAVE  LOCATIONS  FOR  USER  REGISTERS  
;  
ESAV:   DB      0       ; E REGISTER  
DSAV:   DB      0       ; D REGISTER  
CSAV:   DB      0       ; C REGISTER  
BSAV:   DB      0       ; B REGISTER  
FSAV:   DB      0       ; FLAGS  
ASAV:   DB      0       ; A REGISTER  
LSAV:   DB      0       ; L REGISTER  
HSAV:   DB      0       ; H REGISTER  
ISAV:   DB      0       ; INTERRUPT MASK  
PSAV:                   ; PROGRAM COUNTER  
PCLSV:  DB      0       ; LOW ORDER BYTE  
PCHSV:  DB      0       ; HIGH ORDER BYTE  
SSAV:                   ; STACK POINTER  
SPLSV:  DB      0       ; LOW ORDER BYTE  
SPHSV:  DB      0       ; HIGH ORDER BYTE
;  
; ****************************************************************
;  
;  MONITOR STORAGE LOCATIONS  
;
CURAD:  DW      0       ; CURRENT ADDRESS  
CURDT:  DB      0       ; CURRENT DATA  
OBUFF:  DS      4       ; OUTPUT BUFFER  
TEMP:                   ; TEMPORARY LOCATION FOR TTY MONITOR  
                        ; TEMPORARY LOCATION FOR SINGLE STEP ROUTIINE  
RGPTR:  DB      0       ; REGISTER POINTER  
IBUFF:  DB      0       ; INPUT BUFFER  
USCSR:  DB      0       ; USER SHOULD STORE IMAGE OF CSR HERE EACH TIME  
                        ; /CSR IS CHANGED. OTHERWISE, SINGLE STEP
                        ; /ROUTINE WILL DESTROY CSR CONTEIITS.
        END  
